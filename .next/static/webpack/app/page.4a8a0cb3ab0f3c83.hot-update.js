"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/store/graphStore.ts":
/*!*********************************!*\
  !*** ./src/store/graphStore.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EdgeCondition: function() { return /* binding */ EdgeCondition; },\n/* harmony export */   NodeType: function() { return /* binding */ NodeType; },\n/* harmony export */   useGraph: function() { return /* binding */ useGraph; },\n/* harmony export */   useGraphStore: function() { return /* binding */ useGraphStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var _utils_schemaUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/schemaUtils */ \"(app-pages-browser)/./src/utils/schemaUtils.ts\");\n\n\n\n// Helper function to detect cycles in the graph\n// Used for validating Loop nodes\nfunction hasCycleToNode(targetNodeId, edges) {\n    let visited = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Set(), path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new Set(), currentNode = arguments.length > 4 ? arguments[4] : void 0;\n    // If no current node is specified, we need to check all possible starting points\n    if (!currentNode) {\n        // Get all nodes that have edges targeting our loop node\n        const sourcesToTarget = edges.filter((e)=>e.target === targetNodeId).map((e)=>e.source);\n        // For each potential starting point, check if there's a path back to the target\n        for (const source of sourcesToTarget){\n            if (hasCycleToNode(targetNodeId, edges, new Set(), new Set(), source)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // If we've already visited this node in the current path, we found a cycle\n    if (path.has(currentNode)) {\n        return true;\n    }\n    // If we've already visited this node in another path, no need to check again\n    if (visited.has(currentNode)) {\n        return false;\n    }\n    // Mark the current node as visited and add it to the current path\n    visited.add(currentNode);\n    path.add(currentNode);\n    // Check all outgoing edges from the current node\n    const outgoingEdges = edges.filter((e)=>e.source === currentNode);\n    for (const edge of outgoingEdges){\n        // If we find a direct edge back to our target, we found a cycle\n        if (edge.target === targetNodeId) {\n            return true;\n        }\n        // Otherwise, continue searching from the target of this edge\n        if (hasCycleToNode(targetNodeId, edges, visited, path, edge.target)) {\n            return true;\n        }\n    }\n    // Remove the current node from the path as we backtrack\n    path.delete(currentNode);\n    return false;\n}\nvar NodeType;\n(function(NodeType) {\n    NodeType[\"START\"] = \"startNode\";\n    NodeType[\"END\"] = \"endNode\";\n    NodeType[\"AGENT\"] = \"agentNode\";\n    NodeType[\"TOOL\"] = \"toolNode\";\n    NodeType[\"MEMORY_READ\"] = \"memoryReadNode\";\n    NodeType[\"MEMORY_WRITE\"] = \"memoryWriteNode\";\n    NodeType[\"DECISION\"] = \"decisionNode\";\n    NodeType[\"PARALLEL_FORK\"] = \"parallelForkNode\";\n    NodeType[\"PARALLEL_JOIN\"] = \"parallelJoinNode\";\n    NodeType[\"LOOP\"] = \"loopNode\";\n    NodeType[\"ERROR_RETRY\"] = \"errorRetryNode\";\n    NodeType[\"TIMEOUT_GUARD\"] = \"timeoutGuardNode\";\n    NodeType[\"HUMAN_PAUSE\"] = \"humanPauseNode\";\n    NodeType[\"SUBGRAPH\"] = \"subgraphNode\";\n    NodeType[\"CUSTOM\"] = \"customNode\";\n})(NodeType || (NodeType = {}));\nvar EdgeCondition;\n(function(EdgeCondition) {\n    EdgeCondition[\"ALWAYS\"] = \"always\";\n    EdgeCondition[\"SUCCESS\"] = \"success\";\n    EdgeCondition[\"FAILURE\"] = \"failure\";\n    EdgeCondition[\"CUSTOM\"] = \"custom\";\n})(EdgeCondition || (EdgeCondition = {}));\n// Error messages for validation\nconst ERROR_MESSAGES = {\n    START_NODE_EXISTS: \"A graph can only have one START node\",\n    INVALID_CONNECTION: \"This connection is not allowed\",\n    START_REQUIRED: \"A graph must have a START node\",\n    START_NO_INCOMING: \"START nodes cannot have incoming edges\",\n    START_ONE_OUTGOING: \"START node must have exactly one outgoing edge\",\n    END_REQUIRED: \"A graph must have at least one END node\",\n    END_UNREACHABLE: \"All END nodes must have at least one incoming edge\",\n    EDGE_FROM_END: \"END nodes cannot have outgoing edges\",\n    DUPLICATE_EDGE: \"This connection already exists\",\n    SELF_CONNECTION: \"A node cannot connect to itself\",\n    PARALLEL_FORK_MIN_EDGES: \"Parallel Fork nodes must have at least 2 outgoing edges\",\n    PARALLEL_JOIN_MIN_EDGES: \"Parallel Join nodes must have at least 2 incoming edges\",\n    LOOP_CYCLE_REQUIRED: \"Loop nodes must have a cycle\"\n};\n// Create the store\nconst useGraphStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.persist)((set, get)=>({\n        // Initial state\n        nodes: [],\n        edges: [],\n        selectedNodeId: null,\n        selectedEdgeId: null,\n        graphName: \"Untitled Graph\",\n        error: null,\n        isValid: true,\n        // Actions\n        setNodes: (nodes)=>set({\n                nodes\n            }),\n        setEdges: (edges)=>set({\n                edges\n            }),\n        // Validate and add a new node\n        addNode: (node)=>{\n            // Check if we're adding a START node when one already exists\n            if (node.type === \"startNode\" && get().nodes.some((n)=>n.type === \"startNode\")) {\n                set({\n                    error: ERROR_MESSAGES.START_NODE_EXISTS\n                });\n                return;\n            }\n            set((state)=>({\n                    nodes: [\n                        ...state.nodes,\n                        node\n                    ],\n                    error: null\n                }));\n            // Revalidate the graph after adding a node\n            const { valid, message } = get().validateGraph();\n            set({\n                isValid: valid,\n                error: valid ? null : message || null\n            });\n        },\n        // Update node data\n        updateNode: (id, data)=>set((state)=>{\n                const updatedNodes = state.nodes.map((node)=>node.id === id ? {\n                        ...node,\n                        ...data\n                    } : node);\n                // Revalidate the graph after updating a node\n                const newState = {\n                    nodes: updatedNodes\n                };\n                const { valid, message } = get().validateGraph();\n                return {\n                    ...newState,\n                    isValid: valid,\n                    error: valid ? null : message || null\n                };\n            }),\n        // Remove a node and all connected edges\n        removeNode: (id)=>set((state)=>{\n                const newState = {\n                    nodes: state.nodes.filter((node)=>node.id !== id),\n                    edges: state.edges.filter((edge)=>edge.source !== id && edge.target !== id),\n                    // Clear selection if the removed node was selected\n                    selectedNodeId: state.selectedNodeId === id ? null : state.selectedNodeId\n                };\n                // Revalidate the graph after removing a node\n                const { valid, message } = get().validateGraph();\n                return {\n                    ...newState,\n                    isValid: valid,\n                    error: valid ? null : message || null\n                };\n            }),\n        // Validate edge before adding\n        canAddEdge: (source, target)=>{\n            const state = get();\n            const sourceNode = state.nodes.find((n)=>n.id === source);\n            const targetNode = state.nodes.find((n)=>n.id === target);\n            if (!sourceNode || !targetNode) {\n                return {\n                    valid: false,\n                    message: \"Source or target node not found\"\n                };\n            }\n            // Self-connections are not allowed\n            if (source === target) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.SELF_CONNECTION\n                };\n            }\n            // END nodes cannot have outgoing edges\n            if (sourceNode.type === \"endNode\") {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.EDGE_FROM_END\n                };\n            }\n            // Check if this edge already exists\n            if (state.edges.some((e)=>e.source === source && e.target === target)) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.DUPLICATE_EDGE\n                };\n            }\n            // Check type-specific connection rules\n            if (!(0,_utils_schemaUtils__WEBPACK_IMPORTED_MODULE_0__.validateEdgeConnection)(sourceNode.type, targetNode.type)) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.INVALID_CONNECTION\n                };\n            }\n            return {\n                valid: true\n            };\n        },\n        // Add edge with validation\n        addEdge: (edge)=>{\n            const { valid, message } = get().canAddEdge(edge.source, edge.target);\n            if (!valid) {\n                set({\n                    error: message || ERROR_MESSAGES.INVALID_CONNECTION\n                });\n                return;\n            }\n            set((state)=>({\n                    edges: [\n                        ...state.edges,\n                        edge\n                    ],\n                    error: null\n                }));\n            // Revalidate the graph after adding an edge\n            const validationResult = get().validateGraph();\n            set({\n                isValid: validationResult.valid,\n                error: validationResult.valid ? null : validationResult.message || null\n            });\n        },\n        // Update edge data\n        updateEdge: (id, data)=>set((state)=>{\n                const updatedEdges = state.edges.map((edge)=>edge.id === id ? {\n                        ...edge,\n                        ...data\n                    } : edge);\n                return {\n                    edges: updatedEdges\n                };\n            }),\n        // Remove an edge\n        removeEdge: (id)=>set((state)=>{\n                const newState = {\n                    edges: state.edges.filter((edge)=>edge.id !== id),\n                    // Clear selection if the removed edge was selected\n                    selectedEdgeId: state.selectedEdgeId === id ? null : state.selectedEdgeId\n                };\n                // Revalidate the graph after removing an edge\n                const { valid, message } = get().validateGraph();\n                return {\n                    ...newState,\n                    isValid: valid,\n                    error: valid ? null : message || null\n                };\n            }),\n        // Set selected node ID\n        setSelectedNodeId: (id)=>set({\n                selectedNodeId: id,\n                // Deselect edge when selecting a node\n                selectedEdgeId: null\n            }),\n        // Set selected edge ID\n        setSelectedEdgeId: (id)=>set({\n                selectedEdgeId: id,\n                // Deselect node when selecting an edge\n                selectedNodeId: null\n            }),\n        // Set graph name\n        setGraphName: (graphName)=>set({\n                graphName\n            }),\n        // Clear the entire graph\n        clearGraph: ()=>set({\n                nodes: [],\n                edges: [],\n                selectedNodeId: null,\n                selectedEdgeId: null,\n                graphName: \"Untitled Graph\",\n                error: null,\n                isValid: true\n            }),\n        // Validate the entire graph\n        validateGraph: ()=>{\n            const state = get();\n            // Check if there's exactly one START node\n            const startNodes = state.nodes.filter((n)=>n.type === \"startNode\");\n            if (startNodes.length === 0) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_REQUIRED\n                };\n            }\n            if (startNodes.length > 1) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_NODE_EXISTS\n                };\n            }\n            // Validate START node has exactly one outgoing edge and no incoming edges\n            const startNodeId = startNodes[0].id;\n            const startNodeOutgoingEdges = state.edges.filter((e)=>e.source === startNodeId);\n            const startNodeIncomingEdges = state.edges.filter((e)=>e.target === startNodeId);\n            if (startNodeOutgoingEdges.length !== 1) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_ONE_OUTGOING\n                };\n            }\n            if (startNodeIncomingEdges.length > 0) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_NO_INCOMING\n                };\n            }\n            // Check if there's at least one END node\n            const endNodes = state.nodes.filter((n)=>n.type === \"endNode\");\n            if (endNodes.length === 0) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.END_REQUIRED\n                };\n            }\n            // Validate no outgoing edges from END nodes\n            const endNodeIds = endNodes.map((n)=>n.id);\n            const endNodeOutgoingEdges = state.edges.filter((e)=>endNodeIds.includes(e.source));\n            if (endNodeOutgoingEdges.length > 0) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.EDGE_FROM_END\n                };\n            }\n            // Make sure all END nodes have at least one incoming edge (no unreachable END nodes)\n            const endNodesWithoutIncomingEdges = endNodeIds.filter((id)=>{\n                return !state.edges.some((e)=>e.target === id);\n            });\n            if (endNodesWithoutIncomingEdges.length > 0) {\n                return {\n                    valid: false,\n                    message: \"All END nodes must have at least one incoming edge\"\n                };\n            }\n            // Validate Parallel Fork nodes have at least 2 outgoing edges\n            const parallelForkNodes = state.nodes.filter((n)=>n.type === \"parallelForkNode\");\n            for (const forkNode of parallelForkNodes){\n                const outgoingEdges = state.edges.filter((e)=>e.source === forkNode.id);\n                if (outgoingEdges.length < 2) {\n                    return {\n                        valid: false,\n                        message: ERROR_MESSAGES.PARALLEL_FORK_MIN_EDGES\n                    };\n                }\n            }\n            // Validate Parallel Join nodes have at least 2 incoming edges\n            const parallelJoinNodes = state.nodes.filter((n)=>n.type === \"parallelJoinNode\");\n            for (const joinNode of parallelJoinNodes){\n                const incomingEdges = state.edges.filter((e)=>e.target === joinNode.id);\n                if (incomingEdges.length < 2) {\n                    return {\n                        valid: false,\n                        message: ERROR_MESSAGES.PARALLEL_JOIN_MIN_EDGES\n                    };\n                }\n            }\n            // Validate Loop nodes have at least one cycle\n            const loopNodes = state.nodes.filter((n)=>n.type === \"loopNode\");\n            for (const loopNode of loopNodes){\n                // Find if there's a path back to this loop node\n                const hasCycle = hasCycleToNode(loopNode.id, state.edges);\n                if (!hasCycle) {\n                    return {\n                        valid: false,\n                        message: ERROR_MESSAGES.LOOP_CYCLE_REQUIRED\n                    };\n                }\n            }\n            return {\n                valid: true\n            };\n        },\n        // Set error message\n        setError: (error)=>set({\n                error\n            }),\n        // Add a new branch to a decision node\n        addDecisionBranch: (nodeId, branchName)=>set((state)=>{\n                const node = state.nodes.find((n)=>n.id === nodeId);\n                if (!node || node.type !== \"decisionNode\") return state;\n                // Update the node's branches array\n                const updatedNodes = state.nodes.map((n)=>{\n                    if (n.id === nodeId) {\n                        const currentBranches = n.data.branches || [];\n                        return {\n                            ...n,\n                            data: {\n                                ...n.data,\n                                branches: [\n                                    ...currentBranches,\n                                    branchName\n                                ]\n                            }\n                        };\n                    }\n                    return n;\n                });\n                return {\n                    nodes: updatedNodes\n                };\n            }),\n        // Remove a branch from a decision node\n        removeDecisionBranch: (nodeId, branchIndex)=>set((state)=>{\n                const node = state.nodes.find((n)=>n.id === nodeId);\n                if (!node || node.type !== \"decisionNode\") return state;\n                // Update the node's branches array\n                const updatedNodes = state.nodes.map((n)=>{\n                    if (n.id === nodeId && n.data.branches) {\n                        const branches = [\n                            ...n.data.branches\n                        ];\n                        branches.splice(branchIndex, 1);\n                        return {\n                            ...n,\n                            data: {\n                                ...n.data,\n                                branches\n                            }\n                        };\n                    }\n                    return n;\n                });\n                return {\n                    nodes: updatedNodes\n                };\n            }),\n        // Add a cycle connection for a loop node\n        addLoopCycle: (loopNodeId, targetNodeId)=>set((state)=>{\n                // Create a new edge from target to loop node to create a cycle\n                const newEdge = {\n                    id: \"edge-\".concat(loopNodeId, \"-\").concat(targetNodeId, \"-cycle\"),\n                    source: targetNodeId,\n                    target: loopNodeId,\n                    animated: true,\n                    data: {\n                        condition: \"always\"\n                    }\n                };\n                return {\n                    edges: [\n                        ...state.edges,\n                        newEdge\n                    ]\n                };\n            }),\n        // Set a node's parent (for subgraphs)\n        setNodeParent: (nodeId, parentId)=>set((state)=>{\n                const updatedNodes = state.nodes.map((n)=>{\n                    if (n.id === nodeId) {\n                        return {\n                            ...n,\n                            parentNode: parentId || undefined,\n                            // Increase zIndex when node is nested\n                            zIndex: parentId ? 10 : undefined\n                        };\n                    }\n                    return n;\n                });\n                return {\n                    nodes: updatedNodes\n                };\n            })\n    }), {\n    name: \"langgraph-storage\"\n}));\n/* harmony default export */ __webpack_exports__[\"default\"] = (useGraphStore);\n// Custom hook to access graph data conveniently\nconst useGraph = ()=>{\n    const nodes = useGraphStore((state)=>state.nodes);\n    const edges = useGraphStore((state)=>state.edges);\n    const graphName = useGraphStore((state)=>state.graphName);\n    return {\n        nodes,\n        edges,\n        graphName\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9ncmFwaFN0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUM7QUFDWTtBQUNnQjtBQUU3RCxnREFBZ0Q7QUFDaEQsaUNBQWlDO0FBQ2pDLFNBQVNHLGVBQWVDLFlBQW9CLEVBQUVDLEtBQWE7UUFBRUMsVUFBQUEsaUVBQXVCLElBQUlDLE9BQU9DLE9BQUFBLGlFQUFvQixJQUFJRCxPQUFPRTtJQUM1SCxpRkFBaUY7SUFDakYsSUFBSSxDQUFDQSxhQUFhO1FBQ2hCLHdEQUF3RDtRQUN4RCxNQUFNQyxrQkFBa0JMLE1BQ3JCTSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBS1QsY0FDekJVLEdBQUcsQ0FBQ0YsQ0FBQUEsSUFBS0EsRUFBRUcsTUFBTTtRQUVwQixnRkFBZ0Y7UUFDaEYsS0FBSyxNQUFNQSxVQUFVTCxnQkFBaUI7WUFDcEMsSUFBSVAsZUFBZUMsY0FBY0MsT0FBTyxJQUFJRSxPQUFPLElBQUlBLE9BQU9RLFNBQVM7Z0JBQ3JFLE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBRUEsMkVBQTJFO0lBQzNFLElBQUlQLEtBQUtRLEdBQUcsQ0FBQ1AsY0FBYztRQUN6QixPQUFPO0lBQ1Q7SUFFQSw2RUFBNkU7SUFDN0UsSUFBSUgsUUFBUVUsR0FBRyxDQUFDUCxjQUFjO1FBQzVCLE9BQU87SUFDVDtJQUVBLGtFQUFrRTtJQUNsRUgsUUFBUVcsR0FBRyxDQUFDUjtJQUNaRCxLQUFLUyxHQUFHLENBQUNSO0lBRVQsaURBQWlEO0lBQ2pELE1BQU1TLGdCQUFnQmIsTUFBTU0sTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFRyxNQUFNLEtBQUtOO0lBQ3JELEtBQUssTUFBTVUsUUFBUUQsY0FBZTtRQUNoQyxnRUFBZ0U7UUFDaEUsSUFBSUMsS0FBS04sTUFBTSxLQUFLVCxjQUFjO1lBQ2hDLE9BQU87UUFDVDtRQUVBLDZEQUE2RDtRQUM3RCxJQUFJRCxlQUFlQyxj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QUNuQyxJQUFJQSxFQUFFTSxFQUFFLEtBQUtzQyxRQUFRO3dCQUNuQixPQUFPOzRCQUNMLEdBQUc1QyxDQUFDOzRCQUNKMEQsWUFBWUQsWUFBWUU7NEJBQ3hCLHNDQUFzQzs0QkFDdENDLFFBQVFILFdBQVcsS0FBS0U7d0JBQzFCO29CQUNGO29CQUNBLE9BQU8zRDtnQkFDVDtnQkFFQSxPQUFPO29CQUFFWixPQUFPb0I7Z0JBQWE7WUFDL0I7SUFDRixJQUNBO0lBQ0VxRCxNQUFNO0FBQ1IsSUFFRjtBQUVGLCtEQUFlNUUsYUFBYUEsRUFBQztBQUU3QixnREFBZ0Q7QUFDekMsTUFBTTZFLFdBQVc7SUFDdEIsTUFBTTFFLFFBQVFILGNBQWNnQixDQUFBQSxRQUFTQSxNQUFNYixLQUFLO0lBQ2hELE1BQU1uQyxRQUFRZ0MsY0FBY2dCLENBQUFBLFFBQVNBLE1BQU1oRCxLQUFLO0lBQ2hELE1BQU1zQyxZQUFZTixjQUFjZ0IsQ0FBQUEsUUFBU0EsTUFBTVYsU0FBUztJQUN4RCxPQUFPO1FBQUVIO1FBQU9uQztRQUFPc0M7SUFBVTtBQUNuQyxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdG9yZS9ncmFwaFN0b3JlLnRzPzRlZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgeyBwZXJzaXN0IH0gZnJvbSAnenVzdGFuZC9taWRkbGV3YXJlJztcbmltcG9ydCB7IHZhbGlkYXRlRWRnZUNvbm5lY3Rpb24gfSBmcm9tICdAL3V0aWxzL3NjaGVtYVV0aWxzJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVjdCBjeWNsZXMgaW4gdGhlIGdyYXBoXG4vLyBVc2VkIGZvciB2YWxpZGF0aW5nIExvb3Agbm9kZXNcbmZ1bmN0aW9uIGhhc0N5Y2xlVG9Ob2RlKHRhcmdldE5vZGVJZDogc3RyaW5nLCBlZGdlczogRWRnZVtdLCB2aXNpdGVkOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKSwgcGF0aDogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCksIGN1cnJlbnROb2RlPzogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIElmIG5vIGN1cnJlbnQgbm9kZSBpcyBzcGVjaWZpZWQsIHdlIG5lZWQgdG8gY2hlY2sgYWxsIHBvc3NpYmxlIHN0YXJ0aW5nIHBvaW50c1xuICBpZiAoIWN1cnJlbnROb2RlKSB7XG4gICAgLy8gR2V0IGFsbCBub2RlcyB0aGF0IGhhdmUgZWRnZXMgdGFyZ2V0aW5nIG91ciBsb29wIG5vZGVcbiAgICBjb25zdCBzb3VyY2VzVG9UYXJnZXQgPSBlZGdlc1xuICAgICAgLmZpbHRlcihlID0+IGUudGFyZ2V0ID09PSB0YXJnZXROb2RlSWQpXG4gICAgICAubWFwKGUgPT4gZS5zb3VyY2UpO1xuICAgIFxuICAgIC8vIEZvciBlYWNoIHBvdGVudGlhbCBzdGFydGluZyBwb2ludCwgY2hlY2sgaWYgdGhlcmUncyBhIHBhdGggYmFjayB0byB0aGUgdGFyZ2V0XG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlc1RvVGFyZ2V0KSB7XG4gICAgICBpZiAoaGFzQ3ljbGVUb05vZGUodGFyZ2V0Tm9kZUlkLCBlZGdlcywgbmV3IFNldCgpLCBuZXcgU2V0KCksIHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgLy8gSWYgd2UndmUgYWxyZWFkeSB2aXNpdGVkIHRoaXMgbm9kZSBpbiB0aGUgY3VycmVudCBwYXRoLCB3ZSBmb3VuZCBhIGN5Y2xlXG4gIGlmIChwYXRoLmhhcyhjdXJyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBcbiAgLy8gSWYgd2UndmUgYWxyZWFkeSB2aXNpdGVkIHRoaXMgbm9kZSBpbiBhbm90aGVyIHBhdGgsIG5vIG5lZWQgdG8gY2hlY2sgYWdhaW5cbiAgaWYgKHZpc2l0ZWQuaGFzKGN1cnJlbnROb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgLy8gTWFyayB0aGUgY3VycmVudCBub2RlIGFzIHZpc2l0ZWQgYW5kIGFkZCBpdCB0byB0aGUgY3VycmVudCBwYXRoXG4gIHZpc2l0ZWQuYWRkKGN1cnJlbnROb2RlKTtcbiAgcGF0aC5hZGQoY3VycmVudE5vZGUpO1xuICBcbiAgLy8gQ2hlY2sgYWxsIG91dGdvaW5nIGVkZ2VzIGZyb20gdGhlIGN1cnJlbnQgbm9kZVxuICBjb25zdCBvdXRnb2luZ0VkZ2VzID0gZWRnZXMuZmlsdGVyKGUgPT4gZS5zb3VyY2UgPT09IGN1cnJlbnROb2RlKTtcbiAgZm9yIChjb25zdCBlZGdlIG9mIG91dGdvaW5nRWRnZXMpIHtcbiAgICAvLyBJZiB3ZSBmaW5kIGEgZGlyZWN0IGVkZ2UgYmFjayB0byBvdXIgdGFyZ2V0LCB3ZSBmb3VuZCBhIGN5Y2xlXG4gICAgaWYgKGVkZ2UudGFyZ2V0ID09PSB0YXJnZXROb2RlSWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBPdGhlcndpc2UsIGNvbnRpbnVlIHNlYXJjaGluZyBmcm9tIHRoZSB0YXJnZXQgb2YgdGhpcyBlZGdlXG4gICAgaWYgKGhhc0N5Y2xlVG9Ob2RlKHRhcmdldE5vZGVJZCwgZWRnZXMsIHZpc2l0ZWQsIHBhdGgsIGVkZ2UudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIFxuICAvLyBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSBmcm9tIHRoZSBwYXRoIGFzIHdlIGJhY2t0cmFja1xuICBwYXRoLmRlbGV0ZShjdXJyZW50Tm9kZSk7XG4gIFxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIE5vZGUgdHlwZXMgZW51bSBmb3IgaW1wcm92ZWQgdHlwZSBzYWZldHlcbmV4cG9ydCBlbnVtIE5vZGVUeXBlIHtcbiAgU1RBUlQgPSAnc3RhcnROb2RlJyxcbiAgRU5EID0gJ2VuZE5vZGUnLFxuICBBR0VOVCA9ICdhZ2VudE5vZGUnLFxuICBUT09MID0gJ3Rvb2xOb2RlJyxcbiAgTUVNT1JZX1JFQUQgPSAnbWVtb3J5UmVhZE5vZGUnLFxuICBNRU1PUllfV1JJVEUgPSAnbWVtb3J5V3JpdGVOb2RlJyxcbiAgREVDSVNJT04gPSAnZGVjaXNpb25Ob2RlJyxcbiAgUEFSQUxMRUxfRk9SSyA9ICdwYXJhbGxlbEZvcmtOb2RlJyxcbiAgUEFSQUxMRUxfSk9JTiA9ICdwYXJhbGxlbEpvaW5Ob2RlJyxcbiAgTE9PUCA9ICdsb29wTm9kZScsXG4gIEVSUk9SX1JFVFJZID0gJ2Vycm9yUmV0cnlOb2RlJyxcbiAgVElNRU9VVF9HVUFSRCA9ICd0aW1lb3V0R3VhcmROb2RlJyxcbiAgSFVNQU5fUEFVU0UgPSAnaHVtYW5QYXVzZU5vZGUnLFxuICBTVUJHUkFQSCA9ICdzdWJncmFwaE5vZGUnLFxuICBDVVNUT00gPSAnY3VzdG9tTm9kZSdcbn1cblxuLy8gQmFzaWMgbm9kZSBpbnRlcmZhY2VcbmludGVyZmFjZSBOb2RlIHtcbiAgaWQ6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xuICBwb3NpdGlvbjogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICBkYXRhOiB7IGxhYmVsOiBzdHJpbmc7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICBzZWxlY3RlZD86IGJvb2xlYW47XG4gIHBhcmVudE5vZGU/OiBzdHJpbmc7XG4gIHpJbmRleD86IG51bWJlcjtcbn1cblxuLy8gRWRnZSBjb25kaXRpb24gdHlwZXMgZW51bSBmb3IgaW1wcm92ZWQgdHlwZSBzYWZldHlcbmV4cG9ydCBlbnVtIEVkZ2VDb25kaXRpb24ge1xuICBBTFdBWVMgPSAnYWx3YXlzJyxcbiAgU1VDQ0VTUyA9ICdzdWNjZXNzJyxcbiAgRkFJTFVSRSA9ICdmYWlsdXJlJyxcbiAgQ1VTVE9NID0gJ2N1c3RvbSdcbn1cblxuLy8gRW5oYW5jZWQgZWRnZSBpbnRlcmZhY2Ugd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbmludGVyZmFjZSBFZGdlIHtcbiAgaWQ6IHN0cmluZztcbiAgc291cmNlOiBzdHJpbmc7XG4gIHRhcmdldDogc3RyaW5nO1xuICBzb3VyY2VIYW5kbGU/OiBzdHJpbmc7XG4gIHRhcmdldEhhbmRsZT86IHN0cmluZztcbiAgYW5pbWF0ZWQ/OiBib29sZWFuO1xuICBzdHlsZT86IGFueTtcbiAgbGFiZWw/OiBzdHJpbmc7XG4gIGRhdGE/OiB7XG4gICAgY29uZGl0aW9uPzogRWRnZUNvbmRpdGlvbjtcbiAgICBjdXN0b21Db25kaXRpb24/OiBzdHJpbmc7XG4gICAgYnJhbmNoPzogc3RyaW5nO1xuICAgIHByaW9yaXR5PzogbnVtYmVyO1xuICAgIHBhcmFsbGVsQnJhbmNoPzogYm9vbGVhbjtcbiAgICBpc1JldHJ5RWRnZT86IGJvb2xlYW47XG4gIH07XG4gIHNlbGVjdGVkPzogYm9vbGVhbjtcbn1cblxuLy8gRXJyb3IgbWVzc2FnZXMgZm9yIHZhbGlkYXRpb25cbmNvbnN0IEVSUk9SX01FU1NBR0VTID0ge1xuICBTVEFSVF9OT0RFX0VYSVNUUzogJ0EgZ3JhcGggY2FuIG9ubHkgaGF2ZSBvbmUgU1RBUlQgbm9kZScsXG4gIElOVkFMSURfQ09OTkVDVElPTjogJ1RoaXMgY29ubmVjdGlvbiBpcyBub3QgYWxsb3dlZCcsXG4gIFNUQVJUX1JFUVVJUkVEOiAnQSBncmFwaCBtdXN0IGhhdmUgYSBTVEFSVCBub2RlJyxcbiAgU1RBUlRfTk9fSU5DT01JTkc6ICdTVEFSVCBub2RlcyBjYW5ub3QgaGF2ZSBpbmNvbWluZyBlZGdlcycsXG4gIFNUQVJUX09ORV9PVVRHT0lORzogJ1NUQVJUIG5vZGUgbXVzdCBoYXZlIGV4YWN0bHkgb25lIG91dGdvaW5nIGVkZ2UnLFxuICBFTkRfUkVRVUlSRUQ6ICdBIGdyYXBoIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgRU5EIG5vZGUnLFxuICBFTkRfVU5SRUFDSEFCTEU6ICdBbGwgRU5EIG5vZGVzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgaW5jb21pbmcgZWRnZScsXG4gIEVER0VfRlJPTV9FTkQ6ICdFTkQgbm9kZXMgY2Fubm90IGhhdmUgb3V0Z29pbmcgZWRnZXMnLFxuICBEVVBMSUNBVEVfRURHRTogJ1RoaXMgY29ubmVjdGlvbiBhbHJlYWR5IGV4aXN0cycsXG4gIFNFTEZfQ09OTkVDVElPTjogJ0Egbm9kZSBjYW5ub3QgY29ubmVjdCB0byBpdHNlbGYnLFxuICBQQVJBTExFTF9GT1JLX01JTl9FREdFUzogJ1BhcmFsbGVsIEZvcmsgbm9kZXMgbXVzdCBoYXZlIGF0IGxlYXN0IDIgb3V0Z29pbmcgZWRnZXMnLFxuICBQQVJBTExFTF9KT0lOX01JTl9FREdFUzogJ1BhcmFsbGVsIEpvaW4gbm9kZXMgbXVzdCBoYXZlIGF0IGxlYXN0IDIgaW5jb21pbmcgZWRnZXMnLFxuICBMT09QX0NZQ0xFX1JFUVVJUkVEOiAnTG9vcCBub2RlcyBtdXN0IGhhdmUgYSBjeWNsZScsXG59O1xuXG5pbnRlcmZhY2UgR3JhcGhTdGF0ZSB7XG4gIC8vIEdyYXBoIGRhdGFcbiAgbm9kZXM6IE5vZGVbXTtcbiAgZWRnZXM6IEVkZ2VbXTtcbiAgc2VsZWN0ZWROb2RlSWQ6IHN0cmluZyB8IG51bGw7XG4gIHNlbGVjdGVkRWRnZUlkOiBzdHJpbmcgfCBudWxsO1xuICBncmFwaE5hbWU6IHN0cmluZztcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7IC8vIEZvciBzdG9yaW5nIHZhbGlkYXRpb24gZXJyb3JzXG4gIGlzVmFsaWQ6IGJvb2xlYW47IC8vIEZsYWcgaW5kaWNhdGluZyBpZiB0aGUgZ3JhcGggaXMgdmFsaWRcbiAgXG4gIC8vIEFjdGlvbnNcbiAgc2V0Tm9kZXM6IChub2RlczogTm9kZVtdKSA9PiB2b2lkO1xuICBzZXRFZGdlczogKGVkZ2VzOiBFZGdlW10pID0+IHZvaWQ7XG4gIGFkZE5vZGU6IChub2RlOiBOb2RlKSA9PiB2b2lkO1xuICB1cGRhdGVOb2RlOiAoaWQ6IHN0cmluZywgZGF0YTogUGFydGlhbDxOb2RlPikgPT4gdm9pZDtcbiAgcmVtb3ZlTm9kZTogKGlkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGNhbkFkZEVkZ2U6IChzb3VyY2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcpID0+IHsgdmFsaWQ6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmcgfTtcbiAgYWRkRWRnZTogKGVkZ2U6IEVkZ2UpID0+IHZvaWQ7XG4gIHVwZGF0ZUVkZ2U6IChpZDogc3RyaW5nLCBkYXRhOiBQYXJ0aWFsPEVkZ2U+KSA9PiB2b2lkO1xuICByZW1vdmVFZGdlOiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgc2V0U2VsZWN0ZWROb2RlSWQ6IChpZDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbiAgc2V0U2VsZWN0ZWRFZGdlSWQ6IChpZDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbiAgc2V0R3JhcGhOYW1lOiAobmFtZTogc3RyaW5nKSA9PiB2b2lkO1xuICBjbGVhckdyYXBoOiAoKSA9PiB2b2lkO1xuICB2YWxpZGF0ZUdyYXBoOiAoKSA9PiB7IHZhbGlkOiBib29sZWFuOyBtZXNzYWdlPzogc3RyaW5nIH07XG4gIHNldEVycm9yOiAoZXJyb3I6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIFxuICAvLyBOb2RlIHR5cGUgc3BlY2lmaWMgYWN0aW9uc1xuICBhZGREZWNpc2lvbkJyYW5jaDogKG5vZGVJZDogc3RyaW5nLCBicmFuY2hOYW1lOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHJlbW92ZURlY2lzaW9uQnJhbmNoOiAobm9kZUlkOiBzdHJpbmcsIGJyYW5jaEluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG4gIGFkZExvb3BDeWNsZTogKGxvb3BOb2RlSWQ6IHN0cmluZywgdGFyZ2V0Tm9kZUlkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHNldE5vZGVQYXJlbnQ6IChub2RlSWQ6IHN0cmluZywgcGFyZW50SWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG59XG5cbi8vIENyZWF0ZSB0aGUgc3RvcmVcbmV4cG9ydCBjb25zdCB1c2VHcmFwaFN0b3JlID0gY3JlYXRlPEdyYXBoU3RhdGU+KCkoXG4gIHBlcnNpc3QoXG4gICAgKHNldCwgZ2V0KSA9PiAoe1xuICAgICAgLy8gSW5pdGlhbCBzdGF0ZVxuICAgICAgbm9kZXM6IFtdLFxuICAgICAgZWRnZXM6IFtdLFxuICAgICAgc2VsZWN0ZWROb2RlSWQ6IG51bGwsXG4gICAgICBzZWxlY3RlZEVkZ2VJZDogbnVsbCxcbiAgICAgIGdyYXBoTmFtZTogJ1VudGl0bGVkIEdyYXBoJyxcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgIFxuICAgICAgLy8gQWN0aW9uc1xuICAgICAgc2V0Tm9kZXM6IChub2RlcykgPT4gc2V0KHsgbm9kZXMgfSksXG4gICAgICBzZXRFZGdlczogKGVkZ2VzKSA9PiBzZXQoeyBlZGdlcyB9KSxcbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgYW5kIGFkZCBhIG5ldyBub2RlXG4gICAgICBhZGROb2RlOiAobm9kZSkgPT4ge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBhZGRpbmcgYSBTVEFSVCBub2RlIHdoZW4gb25lIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IE5vZGVUeXBlLlNUQVJUICYmIFxuICAgICAgICAgICAgZ2V0KCkubm9kZXMuc29tZShuID0+IG4udHlwZSA9PT0gTm9kZVR5cGUuU1RBUlQpKSB7XG4gICAgICAgICAgc2V0KHsgZXJyb3I6IEVSUk9SX01FU1NBR0VTLlNUQVJUX05PREVfRVhJU1RTIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHsgXG4gICAgICAgICAgbm9kZXM6IFsuLi5zdGF0ZS5ub2Rlcywgbm9kZV0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsIC8vIENsZWFyIGFueSBwcmV2aW91cyBlcnJvcnNcbiAgICAgICAgfSkpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmV2YWxpZGF0ZSB0aGUgZ3JhcGggYWZ0ZXIgYWRkaW5nIGEgbm9kZVxuICAgICAgICBjb25zdCB7IHZhbGlkLCBtZXNzYWdlIH0gPSBnZXQoKS52YWxpZGF0ZUdyYXBoKCk7XG4gICAgICAgIHNldCh7IGlzVmFsaWQ6IHZhbGlkLCBlcnJvcjogdmFsaWQgPyBudWxsIDogbWVzc2FnZSB8fCBudWxsIH0pO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIG5vZGUgZGF0YVxuICAgICAgdXBkYXRlTm9kZTogKGlkLCBkYXRhKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWROb2RlcyA9IHN0YXRlLm5vZGVzLm1hcCgobm9kZSkgPT5cbiAgICAgICAgICBub2RlLmlkID09PSBpZCA/IHsgLi4ubm9kZSwgLi4uZGF0YSB9IDogbm9kZVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gUmV2YWxpZGF0ZSB0aGUgZ3JhcGggYWZ0ZXIgdXBkYXRpbmcgYSBub2RlXG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0geyBub2RlczogdXBkYXRlZE5vZGVzIH07XG4gICAgICAgIGNvbnN0IHsgdmFsaWQsIG1lc3NhZ2UgfSA9IGdldCgpLnZhbGlkYXRlR3JhcGgoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgICBpc1ZhbGlkOiB2YWxpZCxcbiAgICAgICAgICBlcnJvcjogdmFsaWQgPyBudWxsIDogbWVzc2FnZSB8fCBudWxsXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGEgbm9kZSBhbmQgYWxsIGNvbm5lY3RlZCBlZGdlc1xuICAgICAgcmVtb3ZlTm9kZTogKGlkKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgICAgIG5vZGVzOiBzdGF0ZS5ub2Rlcy5maWx0ZXIoKG5vZGUpID0+IG5vZGUuaWQgIT09IGlkKSxcbiAgICAgICAgICBlZGdlczogc3RhdGUuZWRnZXMuZmlsdGVyKFxuICAgICAgICAgICAgKGVkZ2UpID0+IGVkZ2Uuc291cmNlICE9PSBpZCAmJiBlZGdlLnRhcmdldCAhPT0gaWRcbiAgICAgICAgICApLFxuICAgICAgICAgIC8vIENsZWFyIHNlbGVjdGlvbiBpZiB0aGUgcmVtb3ZlZCBub2RlIHdhcyBzZWxlY3RlZFxuICAgICAgICAgIHNlbGVjdGVkTm9kZUlkOiBzdGF0ZS5zZWxlY3RlZE5vZGVJZCA9PT0gaWQgPyBudWxsIDogc3RhdGUuc2VsZWN0ZWROb2RlSWQsXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBSZXZhbGlkYXRlIHRoZSBncmFwaCBhZnRlciByZW1vdmluZyBhIG5vZGVcbiAgICAgICAgY29uc3QgeyB2YWxpZCwgbWVzc2FnZSB9ID0gZ2V0KCkudmFsaWRhdGVHcmFwaCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICAgIGlzVmFsaWQ6IHZhbGlkLFxuICAgICAgICAgIGVycm9yOiB2YWxpZCA/IG51bGwgOiBtZXNzYWdlIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSBlZGdlIGJlZm9yZSBhZGRpbmdcbiAgICAgIGNhbkFkZEVkZ2U6IChzb3VyY2UsIHRhcmdldCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICBjb25zdCBzb3VyY2VOb2RlID0gc3RhdGUubm9kZXMuZmluZChuID0+IG4uaWQgPT09IHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzdGF0ZS5ub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gdGFyZ2V0KTtcbiAgICAgICAgXG4gICAgICAgIGlmICghc291cmNlTm9kZSB8fCAhdGFyZ2V0Tm9kZSkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogJ1NvdXJjZSBvciB0YXJnZXQgbm9kZSBub3QgZm91bmQnIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNlbGYtY29ubmVjdGlvbnMgYXJlIG5vdCBhbGxvd2VkXG4gICAgICAgIGlmIChzb3VyY2UgPT09IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuU0VMRl9DT05ORUNUSU9OIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEVORCBub2RlcyBjYW5ub3QgaGF2ZSBvdXRnb2luZyBlZGdlc1xuICAgICAgICBpZiAoc291cmNlTm9kZS50eXBlID09PSBOb2RlVHlwZS5FTkQpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLkVER0VfRlJPTV9FTkQgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBlZGdlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGlmIChzdGF0ZS5lZGdlcy5zb21lKGUgPT4gZS5zb3VyY2UgPT09IHNvdXJjZSAmJiBlLnRhcmdldCA9PT0gdGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuRFVQTElDQVRFX0VER0UgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgdHlwZS1zcGVjaWZpYyBjb25uZWN0aW9uIHJ1bGVzXG4gICAgICAgIGlmICghdmFsaWRhdGVFZGdlQ29ubmVjdGlvbihzb3VyY2VOb2RlLnR5cGUsIHRhcmdldE5vZGUudHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLklOVkFMSURfQ09OTkVDVElPTiB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgLy8gQWRkIGVkZ2Ugd2l0aCB2YWxpZGF0aW9uXG4gICAgICBhZGRFZGdlOiAoZWRnZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHZhbGlkLCBtZXNzYWdlIH0gPSBnZXQoKS5jYW5BZGRFZGdlKGVkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgc2V0KHsgZXJyb3I6IG1lc3NhZ2UgfHwgRVJST1JfTUVTU0FHRVMuSU5WQUxJRF9DT05ORUNUSU9OIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICBlZGdlczogWy4uLnN0YXRlLmVkZ2VzLCBlZGdlXSxcbiAgICAgICAgICBlcnJvcjogbnVsbCwgLy8gQ2xlYXIgYW55IHByZXZpb3VzIGVycm9yc1xuICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXZhbGlkYXRlIHRoZSBncmFwaCBhZnRlciBhZGRpbmcgYW4gZWRnZVxuICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gZ2V0KCkudmFsaWRhdGVHcmFwaCgpO1xuICAgICAgICBzZXQoeyBcbiAgICAgICAgICBpc1ZhbGlkOiB2YWxpZGF0aW9uUmVzdWx0LnZhbGlkLCBcbiAgICAgICAgICBlcnJvcjogdmFsaWRhdGlvblJlc3VsdC52YWxpZCA/IG51bGwgOiB2YWxpZGF0aW9uUmVzdWx0Lm1lc3NhZ2UgfHwgbnVsbCBcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBVcGRhdGUgZWRnZSBkYXRhXG4gICAgICB1cGRhdGVFZGdlOiAoaWQsIGRhdGEpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEVkZ2VzID0gc3RhdGUuZWRnZXMubWFwKChlZGdlKSA9PlxuICAgICAgICAgIGVkZ2UuaWQgPT09IGlkID8geyAuLi5lZGdlLCAuLi5kYXRhIH0gOiBlZGdlXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBlZGdlczogdXBkYXRlZEVkZ2VzIH07XG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGFuIGVkZ2VcbiAgICAgIHJlbW92ZUVkZ2U6IChpZCkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICBlZGdlczogc3RhdGUuZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLmlkICE9PSBpZCksXG4gICAgICAgICAgLy8gQ2xlYXIgc2VsZWN0aW9uIGlmIHRoZSByZW1vdmVkIGVkZ2Ugd2FzIHNlbGVjdGVkXG4gICAgICAgICAgc2VsZWN0ZWRFZGdlSWQ6IHN0YXRlLnNlbGVjdGVkRWRnZUlkID09PSBpZCA/IG51bGwgOiBzdGF0ZS5zZWxlY3RlZEVkZ2VJZCxcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJldmFsaWRhdGUgdGhlIGdyYXBoIGFmdGVyIHJlbW92aW5nIGFuIGVkZ2VcbiAgICAgICAgY29uc3QgeyB2YWxpZCwgbWVzc2FnZSB9ID0gZ2V0KCkudmFsaWRhdGVHcmFwaCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICAgIGlzVmFsaWQ6IHZhbGlkLFxuICAgICAgICAgIGVycm9yOiB2YWxpZCA/IG51bGwgOiBtZXNzYWdlIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBTZXQgc2VsZWN0ZWQgbm9kZSBJRFxuICAgICAgc2V0U2VsZWN0ZWROb2RlSWQ6IChpZCkgPT4gc2V0KHtcbiAgICAgICAgc2VsZWN0ZWROb2RlSWQ6IGlkLFxuICAgICAgICAvLyBEZXNlbGVjdCBlZGdlIHdoZW4gc2VsZWN0aW5nIGEgbm9kZVxuICAgICAgICBzZWxlY3RlZEVkZ2VJZDogbnVsbCxcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBTZXQgc2VsZWN0ZWQgZWRnZSBJRFxuICAgICAgc2V0U2VsZWN0ZWRFZGdlSWQ6IChpZCkgPT4gc2V0KHtcbiAgICAgICAgc2VsZWN0ZWRFZGdlSWQ6IGlkLFxuICAgICAgICAvLyBEZXNlbGVjdCBub2RlIHdoZW4gc2VsZWN0aW5nIGFuIGVkZ2VcbiAgICAgICAgc2VsZWN0ZWROb2RlSWQ6IG51bGwsXG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gU2V0IGdyYXBoIG5hbWVcbiAgICAgIHNldEdyYXBoTmFtZTogKGdyYXBoTmFtZSkgPT4gc2V0KHsgZ3JhcGhOYW1lIH0pLFxuICAgICAgXG4gICAgICAvLyBDbGVhciB0aGUgZW50aXJlIGdyYXBoXG4gICAgICBjbGVhckdyYXBoOiAoKSA9PiBzZXQoe1xuICAgICAgICBub2RlczogW10sXG4gICAgICAgIGVkZ2VzOiBbXSxcbiAgICAgICAgc2VsZWN0ZWROb2RlSWQ6IG51bGwsXG4gICAgICAgIHNlbGVjdGVkRWRnZUlkOiBudWxsLFxuICAgICAgICBncmFwaE5hbWU6ICdVbnRpdGxlZCBHcmFwaCcsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBlbnRpcmUgZ3JhcGhcbiAgICAgIHZhbGlkYXRlR3JhcGg6ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgZXhhY3RseSBvbmUgU1RBUlQgbm9kZVxuICAgICAgICBjb25zdCBzdGFydE5vZGVzID0gc3RhdGUubm9kZXMuZmlsdGVyKG4gPT4gbi50eXBlID09PSBOb2RlVHlwZS5TVEFSVCk7XG4gICAgICAgIGlmIChzdGFydE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuU1RBUlRfUkVRVUlSRUQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5TVEFSVF9OT0RFX0VYSVNUUyB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSBTVEFSVCBub2RlIGhhcyBleGFjdGx5IG9uZSBvdXRnb2luZyBlZGdlIGFuZCBubyBpbmNvbWluZyBlZGdlc1xuICAgICAgICBjb25zdCBzdGFydE5vZGVJZCA9IHN0YXJ0Tm9kZXNbMF0uaWQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0Tm9kZU91dGdvaW5nRWRnZXMgPSBzdGF0ZS5lZGdlcy5maWx0ZXIoZSA9PiBlLnNvdXJjZSA9PT0gc3RhcnROb2RlSWQpO1xuICAgICAgICBjb25zdCBzdGFydE5vZGVJbmNvbWluZ0VkZ2VzID0gc3RhdGUuZWRnZXMuZmlsdGVyKGUgPT4gZS50YXJnZXQgPT09IHN0YXJ0Tm9kZUlkKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdGFydE5vZGVPdXRnb2luZ0VkZ2VzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuU1RBUlRfT05FX09VVEdPSU5HIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChzdGFydE5vZGVJbmNvbWluZ0VkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLlNUQVJUX05PX0lOQ09NSU5HIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIEVORCBub2RlXG4gICAgICAgIGNvbnN0IGVuZE5vZGVzID0gc3RhdGUubm9kZXMuZmlsdGVyKG4gPT4gbi50eXBlID09PSBOb2RlVHlwZS5FTkQpO1xuICAgICAgICBpZiAoZW5kTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5FTkRfUkVRVUlSRUQgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVmFsaWRhdGUgbm8gb3V0Z29pbmcgZWRnZXMgZnJvbSBFTkQgbm9kZXNcbiAgICAgICAgY29uc3QgZW5kTm9kZUlkcyA9IGVuZE5vZGVzLm1hcChuID0+IG4uaWQpO1xuICAgICAgICAgIFxuICAgICAgICBjb25zdCBlbmROb2RlT3V0Z29pbmdFZGdlcyA9IHN0YXRlLmVkZ2VzLmZpbHRlcihlID0+IGVuZE5vZGVJZHMuaW5jbHVkZXMoZS5zb3VyY2UpKTtcbiAgICAgICAgaWYgKGVuZE5vZGVPdXRnb2luZ0VkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLkVER0VfRlJPTV9FTkQgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCBFTkQgbm9kZXMgaGF2ZSBhdCBsZWFzdCBvbmUgaW5jb21pbmcgZWRnZSAobm8gdW5yZWFjaGFibGUgRU5EIG5vZGVzKVxuICAgICAgICBjb25zdCBlbmROb2Rlc1dpdGhvdXRJbmNvbWluZ0VkZ2VzID0gZW5kTm9kZUlkcy5maWx0ZXIoaWQgPT4ge1xuICAgICAgICAgIHJldHVybiAhc3RhdGUuZWRnZXMuc29tZShlID0+IGUudGFyZ2V0ID09PSBpZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVuZE5vZGVzV2l0aG91dEluY29taW5nRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogJ0FsbCBFTkQgbm9kZXMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBpbmNvbWluZyBlZGdlJyB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSBQYXJhbGxlbCBGb3JrIG5vZGVzIGhhdmUgYXQgbGVhc3QgMiBvdXRnb2luZyBlZGdlc1xuICAgICAgICBjb25zdCBwYXJhbGxlbEZvcmtOb2RlcyA9IHN0YXRlLm5vZGVzLmZpbHRlcihuID0+IG4udHlwZSA9PT0gTm9kZVR5cGUuUEFSQUxMRUxfRk9SSyk7XG4gICAgICAgIGZvciAoY29uc3QgZm9ya05vZGUgb2YgcGFyYWxsZWxGb3JrTm9kZXMpIHtcbiAgICAgICAgICBjb25zdCBvdXRnb2luZ0VkZ2VzID0gc3RhdGUuZWRnZXMuZmlsdGVyKGUgPT4gZS5zb3VyY2UgPT09IGZvcmtOb2RlLmlkKTtcbiAgICAgICAgICBpZiAob3V0Z29pbmdFZGdlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLlBBUkFMTEVMX0ZPUktfTUlOX0VER0VTIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSBQYXJhbGxlbCBKb2luIG5vZGVzIGhhdmUgYXQgbGVhc3QgMiBpbmNvbWluZyBlZGdlc1xuICAgICAgICBjb25zdCBwYXJhbGxlbEpvaW5Ob2RlcyA9IHN0YXRlLm5vZGVzLmZpbHRlcihuID0+IG4udHlwZSA9PT0gTm9kZVR5cGUuUEFSQUxMRUxfSk9JTik7XG4gICAgICAgIGZvciAoY29uc3Qgam9pbk5vZGUgb2YgcGFyYWxsZWxKb2luTm9kZXMpIHtcbiAgICAgICAgICBjb25zdCBpbmNvbWluZ0VkZ2VzID0gc3RhdGUuZWRnZXMuZmlsdGVyKGUgPT4gZS50YXJnZXQgPT09IGpvaW5Ob2RlLmlkKTtcbiAgICAgICAgICBpZiAoaW5jb21pbmdFZGdlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLlBBUkFMTEVMX0pPSU5fTUlOX0VER0VTIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSBMb29wIG5vZGVzIGhhdmUgYXQgbGVhc3Qgb25lIGN5Y2xlXG4gICAgICAgIGNvbnN0IGxvb3BOb2RlcyA9IHN0YXRlLm5vZGVzLmZpbHRlcihuID0+IG4udHlwZSA9PT0gTm9kZVR5cGUuTE9PUCk7XG4gICAgICAgIGZvciAoY29uc3QgbG9vcE5vZGUgb2YgbG9vcE5vZGVzKSB7XG4gICAgICAgICAgLy8gRmluZCBpZiB0aGVyZSdzIGEgcGF0aCBiYWNrIHRvIHRoaXMgbG9vcCBub2RlXG4gICAgICAgICAgY29uc3QgaGFzQ3ljbGUgPSBoYXNDeWNsZVRvTm9kZShsb29wTm9kZS5pZCwgc3RhdGUuZWRnZXMpO1xuICAgICAgICAgIGlmICghaGFzQ3ljbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuTE9PUF9DWUNMRV9SRVFVSVJFRCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIFNldCBlcnJvciBtZXNzYWdlXG4gICAgICBzZXRFcnJvcjogKGVycm9yKSA9PiBzZXQoeyBlcnJvciB9KSxcbiAgICAgIFxuICAgICAgLy8gQWRkIGEgbmV3IGJyYW5jaCB0byBhIGRlY2lzaW9uIG5vZGVcbiAgICAgIGFkZERlY2lzaW9uQnJhbmNoOiAobm9kZUlkLCBicmFuY2hOYW1lKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzdGF0ZS5ub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gbm9kZUlkKTtcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUudHlwZSAhPT0gTm9kZVR5cGUuREVDSVNJT04pIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbm9kZSdzIGJyYW5jaGVzIGFycmF5XG4gICAgICAgIGNvbnN0IHVwZGF0ZWROb2RlcyA9IHN0YXRlLm5vZGVzLm1hcChuID0+IHtcbiAgICAgICAgICBpZiAobi5pZCA9PT0gbm9kZUlkKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QnJhbmNoZXMgPSBuLmRhdGEuYnJhbmNoZXMgfHwgW107XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5uLFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgLi4ubi5kYXRhLFxuICAgICAgICAgICAgICAgIGJyYW5jaGVzOiBbLi4uY3VycmVudEJyYW5jaGVzLCBicmFuY2hOYW1lXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBub2RlczogdXBkYXRlZE5vZGVzIH07XG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGEgYnJhbmNoIGZyb20gYSBkZWNpc2lvbiBub2RlXG4gICAgICByZW1vdmVEZWNpc2lvbkJyYW5jaDogKG5vZGVJZCwgYnJhbmNoSW5kZXgpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXRlLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSBub2RlSWQpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS50eXBlICE9PSBOb2RlVHlwZS5ERUNJU0lPTikgcmV0dXJuIHN0YXRlO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBub2RlJ3MgYnJhbmNoZXMgYXJyYXlcbiAgICAgICAgY29uc3QgdXBkYXRlZE5vZGVzID0gc3RhdGUubm9kZXMubWFwKG4gPT4ge1xuICAgICAgICAgIGlmIChuLmlkID09PSBub2RlSWQgJiYgbi5kYXRhLmJyYW5jaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBicmFuY2hlcyA9IFsuLi5uLmRhdGEuYnJhbmNoZXNdO1xuICAgICAgICAgICAgYnJhbmNoZXMuc3BsaWNlKGJyYW5jaEluZGV4LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLm4sXG4gICAgICAgICAgICAgIGRhdGE6IHsgLi4ubi5kYXRhLCBicmFuY2hlcyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBub2RlczogdXBkYXRlZE5vZGVzIH07XG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gQWRkIGEgY3ljbGUgY29ubmVjdGlvbiBmb3IgYSBsb29wIG5vZGVcbiAgICAgIGFkZExvb3BDeWNsZTogKGxvb3BOb2RlSWQsIHRhcmdldE5vZGVJZCkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZWRnZSBmcm9tIHRhcmdldCB0byBsb29wIG5vZGUgdG8gY3JlYXRlIGEgY3ljbGVcbiAgICAgICAgY29uc3QgbmV3RWRnZTogRWRnZSA9IHtcbiAgICAgICAgICBpZDogYGVkZ2UtJHtsb29wTm9kZUlkfS0ke3RhcmdldE5vZGVJZH0tY3ljbGVgLFxuICAgICAgICAgIHNvdXJjZTogdGFyZ2V0Tm9kZUlkLFxuICAgICAgICAgIHRhcmdldDogbG9vcE5vZGVJZCxcbiAgICAgICAgICBhbmltYXRlZDogdHJ1ZSxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBjb25kaXRpb246IEVkZ2VDb25kaXRpb24uQUxXQVlTLFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IGVkZ2VzOiBbLi4uc3RhdGUuZWRnZXMsIG5ld0VkZ2VdIH07XG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gU2V0IGEgbm9kZSdzIHBhcmVudCAoZm9yIHN1YmdyYXBocylcbiAgICAgIHNldE5vZGVQYXJlbnQ6IChub2RlSWQsIHBhcmVudElkKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWROb2RlcyA9IHN0YXRlLm5vZGVzLm1hcChuID0+IHtcbiAgICAgICAgICBpZiAobi5pZCA9PT0gbm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5uLFxuICAgICAgICAgICAgICBwYXJlbnROb2RlOiBwYXJlbnRJZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIC8vIEluY3JlYXNlIHpJbmRleCB3aGVuIG5vZGUgaXMgbmVzdGVkXG4gICAgICAgICAgICAgIHpJbmRleDogcGFyZW50SWQgPyAxMCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IHVwZGF0ZWROb2RlcyB9O1xuICAgICAgfSksXG4gICAgfSksXG4gICAge1xuICAgICAgbmFtZTogJ2xhbmdncmFwaC1zdG9yYWdlJyxcbiAgICB9XG4gIClcbik7XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUdyYXBoU3RvcmU7XG5cbi8vIEN1c3RvbSBob29rIHRvIGFjY2VzcyBncmFwaCBkYXRhIGNvbnZlbmllbnRseVxuZXhwb3J0IGNvbnN0IHVzZUdyYXBoID0gKCkgPT4ge1xuICBjb25zdCBub2RlcyA9IHVzZUdyYXBoU3RvcmUoc3RhdGUgPT4gc3RhdGUubm9kZXMpO1xuICBjb25zdCBlZGdlcyA9IHVzZUdyYXBoU3RvcmUoc3RhdGUgPT4gc3RhdGUuZWRnZXMpO1xuICBjb25zdCBncmFwaE5hbWUgPSB1c2VHcmFwaFN0b3JlKHN0YXRlID0+IHN0YXRlLmdyYXBoTmFtZSk7XG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcywgZ3JhcGhOYW1lIH07XG59O1xuIl0sIm5hbWVzIjpbImNyZWF0ZSIsInBlcnNpc3QiLCJ2YWxpZGF0ZUVkZ2VDb25uZWN0aW9uIiwiaGFzQ3ljbGVUb05vZGUiLCJ0YXJnZXROb2RlSWQiLCJlZGdlcyIsInZpc2l0ZWQiLCJTZXQiLCJwYXRoIiwiY3VycmVudE5vZGUiLCJzb3VyY2VzVG9UYXJnZXQiLCJmaWx0ZXIiLCJlIiwidGFyZ2V0IiwibWFwIiwic291cmNlIiwiaGFzIiwiYWRkIiwib3V0Z29pbmdFZGdlcyIsImVkZ2UiLCJkZWxldGUiLCJOb2RlVHlwZSIsIkVkZ2VDb25kaXRpb24iLCJFUlJPUl9NRVNTQUdFUyIsIlNUQVJUX05PREVfRVhJU1RTIiwiSU5WQUxJRF9DT05ORUNUSU9OIiwiU1RBUlRfUkVRVUlSRUQiLCJTVEFSVF9OT19JTkNPTUlORyIsIlNUQVJUX09ORV9PVVRHT0lORyIsIkVORF9SRVFVSVJFRCIsIkVORF9VTlJFQUNIQUJMRSIsIkVER0VfRlJPTV9FTkQiLCJEVVBMSUNBVEVfRURHRSIsIlNFTEZfQ09OTkVDVElPTiIsIlBBUkFMTEVMX0ZPUktfTUlOX0VER0VTIiwiUEFSQUxMRUxfSk9JTl9NSU5fRURHRVMiLCJMT09QX0NZQ0xFX1JFUVVJUkVEIiwidXNlR3JhcGhTdG9yZSIsInNldCIsImdldCIsIm5vZGVzIiwic2VsZWN0ZWROb2RlSWQiLCJzZWxlY3RlZEVkZ2VJZCIsImdyYXBoTmFtZSIsImVycm9yIiwiaXNWYWxpZCIsInNldE5vZGVzIiwic2V0RWRnZXMiLCJhZGROb2RlIiwibm9kZSIsInR5cGUiLCJzb21lIiwibiIsInN0YXRlIiwidmFsaWQiLCJtZXNzYWdlIiwidmFsaWRhdGVHcmFwaCIsInVwZGF0ZU5vZGUiLCJpZCIsImRhdGEiLCJ1cGRhdGVkTm9kZXMiLCJuZXdTdGF0ZSIsInJlbW92ZU5vZGUiLCJjYW5BZGRFZGdlIiwic291cmNlTm9kZSIsImZpbmQiLCJ0YXJnZXROb2RlIiwiYWRkRWRnZSIsInZhbGlkYXRpb25SZXN1bHQiLCJ1cGRhdGVFZGdlIiwidXBkYXRlZEVkZ2VzIiwicmVtb3ZlRWRnZSIsInNldFNlbGVjdGVkTm9kZUlkIiwic2V0U2VsZWN0ZWRFZGdlSWQiLCJzZXRHcmFwaE5hbWUiLCJjbGVhckdyYXBoIiwic3RhcnROb2RlcyIsImxlbmd0aCIsInN0YXJ0Tm9kZUlkIiwic3RhcnROb2RlT3V0Z29pbmdFZGdlcyIsInN0YXJ0Tm9kZUluY29taW5nRWRnZXMiLCJlbmROb2RlcyIsImVuZE5vZGVJZHMiLCJlbmROb2RlT3V0Z29pbmdFZGdlcyIsImluY2x1ZGVzIiwiZW5kTm9kZXNXaXRob3V0SW5jb21pbmdFZGdlcyIsInBhcmFsbGVsRm9ya05vZGVzIiwiZm9ya05vZGUiLCJwYXJhbGxlbEpvaW5Ob2RlcyIsImpvaW5Ob2RlIiwiaW5jb21pbmdFZGdlcyIsImxvb3BOb2RlcyIsImxvb3BOb2RlIiwiaGFzQ3ljbGUiLCJzZXRFcnJvciIsImFkZERlY2lzaW9uQnJhbmNoIiwibm9kZUlkIiwiYnJhbmNoTmFtZSIsImN1cnJlbnRCcmFuY2hlcyIsImJyYW5jaGVzIiwicmVtb3ZlRGVjaXNpb25CcmFuY2giLCJicmFuY2hJbmRleCIsInNwbGljZSIsImFkZExvb3BDeWNsZSIsImxvb3BOb2RlSWQiLCJuZXdFZGdlIiwiYW5pbWF0ZWQiLCJjb25kaXRpb24iLCJzZXROb2RlUGFyZW50IiwicGFyZW50SWQiLCJwYXJlbnROb2RlIiwidW5kZWZpbmVkIiwiekluZGV4IiwibmFtZSIsInVzZUdyYXBoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/graphStore.ts\n"));

/***/ })

});