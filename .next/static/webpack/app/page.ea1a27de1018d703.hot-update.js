"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/store/graphStore.ts":
/*!*********************************!*\
  !*** ./src/store/graphStore.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EdgeCondition: function() { return /* binding */ EdgeCondition; },\n/* harmony export */   NodeType: function() { return /* binding */ NodeType; },\n/* harmony export */   useGraph: function() { return /* binding */ useGraph; },\n/* harmony export */   useGraphStore: function() { return /* binding */ useGraphStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var _utils_schemaUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/schemaUtils */ \"(app-pages-browser)/./src/utils/schemaUtils.ts\");\n\n\n\n// Helper function to detect cycles in the graph\n// Used for validating Loop nodes\nfunction hasCycleToNode(targetNodeId, edges) {\n    let visited = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Set(), path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new Set(), currentNode = arguments.length > 4 ? arguments[4] : void 0;\n    // If no current node is specified, we need to check all possible starting points\n    if (!currentNode) {\n        // Get all nodes that have edges targeting our loop node\n        const sourcesToTarget = edges.filter((e)=>e.target === targetNodeId).map((e)=>e.source);\n        // For each potential starting point, check if there's a path back to the target\n        for (const source of sourcesToTarget){\n            if (hasCycleToNode(targetNodeId, edges, new Set(), new Set(), source)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // If we've already visited this node in the current path, we found a cycle\n    if (path.has(currentNode)) {\n        return true;\n    }\n    // If we've already visited this node in another path, no need to check again\n    if (visited.has(currentNode)) {\n        return false;\n    }\n    // Mark the current node as visited and add it to the current path\n    visited.add(currentNode);\n    path.add(currentNode);\n    // Check all outgoing edges from the current node\n    const outgoingEdges = edges.filter((e)=>e.source === currentNode);\n    for (const edge of outgoingEdges){\n        // If we find a direct edge back to our target, we found a cycle\n        if (edge.target === targetNodeId) {\n            return true;\n        }\n        // Otherwise, continue searching from the target of this edge\n        if (hasCycleToNode(targetNodeId, edges, visited, path, edge.target)) {\n            return true;\n        }\n    }\n    // Remove the current node from the path as we backtrack\n    path.delete(currentNode);\n    return false;\n}\nvar NodeType;\n(function(NodeType) {\n    NodeType[\"START\"] = \"startNode\";\n    NodeType[\"END\"] = \"endNode\";\n    NodeType[\"AGENT\"] = \"agentNode\";\n    NodeType[\"TOOL\"] = \"toolNode\";\n    NodeType[\"MEMORY_READ\"] = \"memoryReadNode\";\n    NodeType[\"MEMORY_WRITE\"] = \"memoryWriteNode\";\n    NodeType[\"DECISION\"] = \"decisionNode\";\n    NodeType[\"PARALLEL_FORK\"] = \"parallelForkNode\";\n    NodeType[\"PARALLEL_JOIN\"] = \"parallelJoinNode\";\n    NodeType[\"LOOP\"] = \"loopNode\";\n    NodeType[\"ERROR_RETRY\"] = \"errorRetryNode\";\n    NodeType[\"TIMEOUT_GUARD\"] = \"timeoutGuardNode\";\n    NodeType[\"HUMAN_PAUSE\"] = \"humanPauseNode\";\n    NodeType[\"SUBGRAPH\"] = \"subgraphNode\";\n    NodeType[\"CUSTOM\"] = \"customNode\";\n})(NodeType || (NodeType = {}));\nvar EdgeCondition;\n(function(EdgeCondition) {\n    EdgeCondition[\"ALWAYS\"] = \"always\";\n    EdgeCondition[\"SUCCESS\"] = \"success\";\n    EdgeCondition[\"FAILURE\"] = \"failure\";\n    EdgeCondition[\"CUSTOM\"] = \"custom\";\n})(EdgeCondition || (EdgeCondition = {}));\n// Error messages for validation\nconst ERROR_MESSAGES = {\n    START_NODE_EXISTS: \"A graph can only have one START node\",\n    INVALID_CONNECTION: \"This connection is not allowed\",\n    START_REQUIRED: \"A graph must have a START node\",\n    START_NO_INCOMING: \"START nodes cannot have incoming edges\",\n    START_ONE_OUTGOING: \"START node must have exactly one outgoing edge\",\n    EDGE_FROM_END: \"END nodes cannot have outgoing edges\",\n    DUPLICATE_EDGE: \"This connection already exists\",\n    SELF_CONNECTION: \"A node cannot connect to itself\",\n    PARALLEL_FORK_MIN_EDGES: \"Parallel Fork nodes must have at least 2 outgoing edges\",\n    PARALLEL_JOIN_MIN_EDGES: \"Parallel Join nodes must have at least 2 incoming edges\",\n    LOOP_CYCLE_REQUIRED: \"Loop nodes must have a cycle\"\n};\n// Create the store\nconst useGraphStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.persist)((set, get)=>({\n        // Initial state\n        nodes: [],\n        edges: [],\n        selectedNodeId: null,\n        selectedEdgeId: null,\n        graphName: \"Untitled Graph\",\n        error: null,\n        isValid: true,\n        // Actions\n        setNodes: (nodes)=>set({\n                nodes\n            }),\n        setEdges: (edges)=>set({\n                edges\n            }),\n        // Validate and add a new node\n        addNode: (node)=>{\n            // Check if we're adding a START node when one already exists\n            if (node.type === \"startNode\" && get().nodes.some((n)=>n.type === \"startNode\")) {\n                set({\n                    error: ERROR_MESSAGES.START_NODE_EXISTS\n                });\n                return;\n            }\n            set((state)=>({\n                    nodes: [\n                        ...state.nodes,\n                        node\n                    ],\n                    error: null\n                }));\n            // Revalidate the graph after adding a node\n            const { valid, message } = get().validateGraph();\n            set({\n                isValid: valid,\n                error: valid ? null : message || null\n            });\n        },\n        // Update node data\n        updateNode: (id, data)=>set((state)=>{\n                const updatedNodes = state.nodes.map((node)=>node.id === id ? {\n                        ...node,\n                        ...data\n                    } : node);\n                // Revalidate the graph after updating a node\n                const newState = {\n                    nodes: updatedNodes\n                };\n                const { valid, message } = get().validateGraph();\n                return {\n                    ...newState,\n                    isValid: valid,\n                    error: valid ? null : message || null\n                };\n            }),\n        // Remove a node and all connected edges\n        removeNode: (id)=>set((state)=>{\n                const newState = {\n                    nodes: state.nodes.filter((node)=>node.id !== id),\n                    edges: state.edges.filter((edge)=>edge.source !== id && edge.target !== id),\n                    // Clear selection if the removed node was selected\n                    selectedNodeId: state.selectedNodeId === id ? null : state.selectedNodeId\n                };\n                // Revalidate the graph after removing a node\n                const { valid, message } = get().validateGraph();\n                return {\n                    ...newState,\n                    isValid: valid,\n                    error: valid ? null : message || null\n                };\n            }),\n        // Validate edge before adding\n        canAddEdge: (source, target)=>{\n            const state = get();\n            const sourceNode = state.nodes.find((n)=>n.id === source);\n            const targetNode = state.nodes.find((n)=>n.id === target);\n            if (!sourceNode || !targetNode) {\n                return {\n                    valid: false,\n                    message: \"Source or target node not found\"\n                };\n            }\n            // Self-connections are not allowed\n            if (source === target) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.SELF_CONNECTION\n                };\n            }\n            // END nodes cannot have outgoing edges\n            if (sourceNode.type === \"endNode\") {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.EDGE_FROM_END\n                };\n            }\n            // Check if this edge already exists\n            if (state.edges.some((e)=>e.source === source && e.target === target)) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.DUPLICATE_EDGE\n                };\n            }\n            // Check type-specific connection rules\n            if (!(0,_utils_schemaUtils__WEBPACK_IMPORTED_MODULE_0__.validateEdgeConnection)(sourceNode.type, targetNode.type)) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.INVALID_CONNECTION\n                };\n            }\n            return {\n                valid: true\n            };\n        },\n        // Add edge with validation\n        addEdge: (edge)=>{\n            const { valid, message } = get().canAddEdge(edge.source, edge.target);\n            if (!valid) {\n                set({\n                    error: message || ERROR_MESSAGES.INVALID_CONNECTION\n                });\n                return;\n            }\n            set((state)=>({\n                    edges: [\n                        ...state.edges,\n                        edge\n                    ],\n                    error: null\n                }));\n            // Revalidate the graph after adding an edge\n            const validationResult = get().validateGraph();\n            set({\n                isValid: validationResult.valid,\n                error: validationResult.valid ? null : validationResult.message || null\n            });\n        },\n        // Update edge data\n        updateEdge: (id, data)=>set((state)=>{\n                const updatedEdges = state.edges.map((edge)=>edge.id === id ? {\n                        ...edge,\n                        ...data\n                    } : edge);\n                return {\n                    edges: updatedEdges\n                };\n            }),\n        // Remove an edge\n        removeEdge: (id)=>set((state)=>{\n                const newState = {\n                    edges: state.edges.filter((edge)=>edge.id !== id),\n                    // Clear selection if the removed edge was selected\n                    selectedEdgeId: state.selectedEdgeId === id ? null : state.selectedEdgeId\n                };\n                // Revalidate the graph after removing an edge\n                const { valid, message } = get().validateGraph();\n                return {\n                    ...newState,\n                    isValid: valid,\n                    error: valid ? null : message || null\n                };\n            }),\n        // Set selected node ID\n        setSelectedNodeId: (id)=>set({\n                selectedNodeId: id,\n                // Deselect edge when selecting a node\n                selectedEdgeId: null\n            }),\n        // Set selected edge ID\n        setSelectedEdgeId: (id)=>set({\n                selectedEdgeId: id,\n                // Deselect node when selecting an edge\n                selectedNodeId: null\n            }),\n        // Set graph name\n        setGraphName: (graphName)=>set({\n                graphName\n            }),\n        // Clear the entire graph\n        clearGraph: ()=>set({\n                nodes: [],\n                edges: [],\n                selectedNodeId: null,\n                selectedEdgeId: null,\n                graphName: \"Untitled Graph\",\n                error: null,\n                isValid: true\n            }),\n        // Validate the entire graph\n        validateGraph: ()=>{\n            const state = get();\n            // Check if there's exactly one START node\n            const startNodes = state.nodes.filter((n)=>n.type === \"startNode\");\n            if (startNodes.length === 0) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_REQUIRED\n                };\n            }\n            if (startNodes.length > 1) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_NODE_EXISTS\n                };\n            }\n            // Validate START node has exactly one outgoing edge and no incoming edges\n            const startNodeId = startNodes[0].id;\n            const startNodeOutgoingEdges = state.edges.filter((e)=>e.source === startNodeId);\n            const startNodeIncomingEdges = state.edges.filter((e)=>e.target === startNodeId);\n            if (startNodeOutgoingEdges.length !== 1) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_ONE_OUTGOING\n                };\n            }\n            if (startNodeIncomingEdges.length > 0) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_NO_INCOMING\n                };\n            }\n            // Validate no outgoing edges from END nodes\n            const endNodeIds = state.nodes.filter((n)=>n.type === \"endNode\").map((n)=>n.id);\n            const endNodeOutgoingEdges = state.edges.filter((e)=>endNodeIds.includes(e.source));\n            if (endNodeOutgoingEdges.length > 0) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.EDGE_FROM_END\n                };\n            }\n            // Validate Parallel Fork nodes have at least 2 outgoing edges\n            const parallelForkNodes = state.nodes.filter((n)=>n.type === \"parallelForkNode\");\n            for (const forkNode of parallelForkNodes){\n                const outgoingEdges = state.edges.filter((e)=>e.source === forkNode.id);\n                if (outgoingEdges.length < 2) {\n                    return {\n                        valid: false,\n                        message: ERROR_MESSAGES.PARALLEL_FORK_MIN_EDGES\n                    };\n                }\n            }\n            // Validate Parallel Join nodes have at least 2 incoming edges\n            const parallelJoinNodes = state.nodes.filter((n)=>n.type === \"parallelJoinNode\");\n            for (const joinNode of parallelJoinNodes){\n                const incomingEdges = state.edges.filter((e)=>e.target === joinNode.id);\n                if (incomingEdges.length < 2) {\n                    return {\n                        valid: false,\n                        message: ERROR_MESSAGES.PARALLEL_JOIN_MIN_EDGES\n                    };\n                }\n            }\n            // Validate Loop nodes have at least one cycle\n            const loopNodes = state.nodes.filter((n)=>n.type === \"loopNode\");\n            for (const loopNode of loopNodes){\n                // Find if there's a path back to this loop node\n                const hasCycle = hasCycleToNode(loopNode.id, state.edges);\n                if (!hasCycle) {\n                    return {\n                        valid: false,\n                        message: ERROR_MESSAGES.LOOP_CYCLE_REQUIRED\n                    };\n                }\n            }\n            return {\n                valid: true\n            };\n        },\n        // Set error message\n        setError: (error)=>set({\n                error\n            }),\n        // Add a new branch to a decision node\n        addDecisionBranch: (nodeId, branchName)=>set((state)=>{\n                const node = state.nodes.find((n)=>n.id === nodeId);\n                if (!node || node.type !== \"decisionNode\") return state;\n                // Update the node's branches array\n                const updatedNodes = state.nodes.map((n)=>{\n                    if (n.id === nodeId) {\n                        const currentBranches = n.data.branches || [];\n                        return {\n                            ...n,\n                            data: {\n                                ...n.data,\n                                branches: [\n                                    ...currentBranches,\n                                    branchName\n                                ]\n                            }\n                        };\n                    }\n                    return n;\n                });\n                return {\n                    nodes: updatedNodes\n                };\n            }),\n        // Remove a branch from a decision node\n        removeDecisionBranch: (nodeId, branchIndex)=>set((state)=>{\n                const node = state.nodes.find((n)=>n.id === nodeId);\n                if (!node || node.type !== \"decisionNode\") return state;\n                // Update the node's branches array\n                const updatedNodes = state.nodes.map((n)=>{\n                    if (n.id === nodeId && n.data.branches) {\n                        const branches = [\n                            ...n.data.branches\n                        ];\n                        branches.splice(branchIndex, 1);\n                        return {\n                            ...n,\n                            data: {\n                                ...n.data,\n                                branches\n                            }\n                        };\n                    }\n                    return n;\n                });\n                return {\n                    nodes: updatedNodes\n                };\n            }),\n        // Add a cycle connection for a loop node\n        addLoopCycle: (loopNodeId, targetNodeId)=>set((state)=>{\n                // Create a new edge from target to loop node to create a cycle\n                const newEdge = {\n                    id: \"edge-\".concat(loopNodeId, \"-\").concat(targetNodeId, \"-cycle\"),\n                    source: targetNodeId,\n                    target: loopNodeId,\n                    animated: true,\n                    data: {\n                        condition: \"always\"\n                    }\n                };\n                return {\n                    edges: [\n                        ...state.edges,\n                        newEdge\n                    ]\n                };\n            }),\n        // Set a node's parent (for subgraphs)\n        setNodeParent: (nodeId, parentId)=>set((state)=>{\n                const updatedNodes = state.nodes.map((n)=>{\n                    if (n.id === nodeId) {\n                        return {\n                            ...n,\n                            parentNode: parentId || undefined,\n                            // Increase zIndex when node is nested\n                            zIndex: parentId ? 10 : undefined\n                        };\n                    }\n                    return n;\n                });\n                return {\n                    nodes: updatedNodes\n                };\n            })\n    }), {\n    name: \"langgraph-storage\"\n}));\n/* harmony default export */ __webpack_exports__[\"default\"] = (useGraphStore);\n// Custom hook to access graph data conveniently\nconst useGraph = ()=>{\n    const nodes = useGraphStore((state)=>state.nodes);\n    const edges = useGraphStore((state)=>state.edges);\n    const graphName = useGraphStore((state)=>state.graphName);\n    return {\n        nodes,\n        edges,\n        graphName\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9ncmFwaFN0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUM7QUFDWTtBQUNnQjtBQUU3RCxnREFBZ0Q7QUFDaEQsaUNBQWlDO0FBQ2pDLFNBQVNHLGVBQWVDLFlBQW9CLEVBQUVDLEtBQWE7UUFBRUMsVUFBQUEsaUVBQXVCLElBQUlDLE9BQU9DLE9BQUFBLGlFQUFvQixJQUFJRCxPQUFPRTtJQUM1SCxpRkFBaUY7SUFDakYsSUFBSSxDQUFDQSxhQUFhO1FBQ2hCLHdEQUF3RDtRQUN4RCxNQUFNQyxrQkFBa0JMLE1BQ3JCTSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBS1QsY0FDekJVLEdBQUcsQ0FBQ0YsQ0FBQUEsSUFBS0EsRUFBRUcsTUFBTTtRQUVwQixnRkFBZ0Y7UUFDaEYsS0FBSyxNQUFNQSxVQUFVTCxnQkFBaUI7WUFDcEMsSUFBSVAsZUFBZUMsY0FBY0MsT0FBTyxJQUFJRSxPQUFPLElBQUlBLE9BQU9RLFNBQVM7Z0JBQ3JFLE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBRUEsMkVBQTJFO0lBQzNFLElBQUlQLEtBQUtRLEdBQUcsQ0FBQ1AsY0FBYztRQUN6QixPQUFPO0lBQ1Q7SUFFQSw2RUFBNkU7SUFDN0UsSUFBSUgsUUFBUVUsR0FBRyxDQUFDUCxjQUFjO1FBQzVCLE9BQU87SUFDVDtJQUVBLGtFQUFrRTtJQUNsRUgsUUFBUVcsR0FBRyxDQUFDUjtJQUNaRCxLQUFLUyxHQUFHLENBQUNSO0lBRVQsaURBQWlEO0lBQ2pELE1BQU1TLGdCQUFnQmIsTUFBTU0sTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFRyxNQUFNLEtBQUtOO0lBQ3JELEtBQUssTUFBTVUsUUFBUUQsY0FBZTtRQUNoQyxnRUFBZ0U7UUFDaEUsSUFBSUMsS0FBS04sTUFBTSxLQUFLVCxjQUFjO1lBQ2hDLE9BQU87UUFDVDtRQUVBLDZEQUE2RDtRQUM3RCxJQUFJRCxlQUFlQyxj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SztJQUNoRCxNQUFNb0MsWUFBWU4sY0FBY2dCLENBQUFBLFFBQVNBLE1BQU1WLFNBQVM7SUFDeEQsT0FBTztRQUFFSDtRQUFPakM7UUFBT29DO0lBQVU7QUFDbkMsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3RvcmUvZ3JhcGhTdG9yZS50cz80ZWZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnO1xuaW1wb3J0IHsgcGVyc2lzdCB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XG5pbXBvcnQgeyB2YWxpZGF0ZUVkZ2VDb25uZWN0aW9uIH0gZnJvbSAnQC91dGlscy9zY2hlbWFVdGlscyc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBkZXRlY3QgY3ljbGVzIGluIHRoZSBncmFwaFxuLy8gVXNlZCBmb3IgdmFsaWRhdGluZyBMb29wIG5vZGVzXG5mdW5jdGlvbiBoYXNDeWNsZVRvTm9kZSh0YXJnZXROb2RlSWQ6IHN0cmluZywgZWRnZXM6IEVkZ2VbXSwgdmlzaXRlZDogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCksIHBhdGg6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpLCBjdXJyZW50Tm9kZT86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBJZiBubyBjdXJyZW50IG5vZGUgaXMgc3BlY2lmaWVkLCB3ZSBuZWVkIHRvIGNoZWNrIGFsbCBwb3NzaWJsZSBzdGFydGluZyBwb2ludHNcbiAgaWYgKCFjdXJyZW50Tm9kZSkge1xuICAgIC8vIEdldCBhbGwgbm9kZXMgdGhhdCBoYXZlIGVkZ2VzIHRhcmdldGluZyBvdXIgbG9vcCBub2RlXG4gICAgY29uc3Qgc291cmNlc1RvVGFyZ2V0ID0gZWRnZXNcbiAgICAgIC5maWx0ZXIoZSA9PiBlLnRhcmdldCA9PT0gdGFyZ2V0Tm9kZUlkKVxuICAgICAgLm1hcChlID0+IGUuc291cmNlKTtcbiAgICBcbiAgICAvLyBGb3IgZWFjaCBwb3RlbnRpYWwgc3RhcnRpbmcgcG9pbnQsIGNoZWNrIGlmIHRoZXJlJ3MgYSBwYXRoIGJhY2sgdG8gdGhlIHRhcmdldFxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXNUb1RhcmdldCkge1xuICAgICAgaWYgKGhhc0N5Y2xlVG9Ob2RlKHRhcmdldE5vZGVJZCwgZWRnZXMsIG5ldyBTZXQoKSwgbmV3IFNldCgpLCBzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIC8vIElmIHdlJ3ZlIGFscmVhZHkgdmlzaXRlZCB0aGlzIG5vZGUgaW4gdGhlIGN1cnJlbnQgcGF0aCwgd2UgZm91bmQgYSBjeWNsZVxuICBpZiAocGF0aC5oYXMoY3VycmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIC8vIElmIHdlJ3ZlIGFscmVhZHkgdmlzaXRlZCB0aGlzIG5vZGUgaW4gYW5vdGhlciBwYXRoLCBubyBuZWVkIHRvIGNoZWNrIGFnYWluXG4gIGlmICh2aXNpdGVkLmhhcyhjdXJyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIC8vIE1hcmsgdGhlIGN1cnJlbnQgbm9kZSBhcyB2aXNpdGVkIGFuZCBhZGQgaXQgdG8gdGhlIGN1cnJlbnQgcGF0aFxuICB2aXNpdGVkLmFkZChjdXJyZW50Tm9kZSk7XG4gIHBhdGguYWRkKGN1cnJlbnROb2RlKTtcbiAgXG4gIC8vIENoZWNrIGFsbCBvdXRnb2luZyBlZGdlcyBmcm9tIHRoZSBjdXJyZW50IG5vZGVcbiAgY29uc3Qgb3V0Z29pbmdFZGdlcyA9IGVkZ2VzLmZpbHRlcihlID0+IGUuc291cmNlID09PSBjdXJyZW50Tm9kZSk7XG4gIGZvciAoY29uc3QgZWRnZSBvZiBvdXRnb2luZ0VkZ2VzKSB7XG4gICAgLy8gSWYgd2UgZmluZCBhIGRpcmVjdCBlZGdlIGJhY2sgdG8gb3VyIHRhcmdldCwgd2UgZm91bmQgYSBjeWNsZVxuICAgIGlmIChlZGdlLnRhcmdldCA9PT0gdGFyZ2V0Tm9kZUlkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gT3RoZXJ3aXNlLCBjb250aW51ZSBzZWFyY2hpbmcgZnJvbSB0aGUgdGFyZ2V0IG9mIHRoaXMgZWRnZVxuICAgIGlmIChoYXNDeWNsZVRvTm9kZSh0YXJnZXROb2RlSWQsIGVkZ2VzLCB2aXNpdGVkLCBwYXRoLCBlZGdlLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUgZnJvbSB0aGUgcGF0aCBhcyB3ZSBiYWNrdHJhY2tcbiAgcGF0aC5kZWxldGUoY3VycmVudE5vZGUpO1xuICBcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBOb2RlIHR5cGVzIGVudW0gZm9yIGltcHJvdmVkIHR5cGUgc2FmZXR5XG5leHBvcnQgZW51bSBOb2RlVHlwZSB7XG4gIFNUQVJUID0gJ3N0YXJ0Tm9kZScsXG4gIEVORCA9ICdlbmROb2RlJyxcbiAgQUdFTlQgPSAnYWdlbnROb2RlJyxcbiAgVE9PTCA9ICd0b29sTm9kZScsXG4gIE1FTU9SWV9SRUFEID0gJ21lbW9yeVJlYWROb2RlJyxcbiAgTUVNT1JZX1dSSVRFID0gJ21lbW9yeVdyaXRlTm9kZScsXG4gIERFQ0lTSU9OID0gJ2RlY2lzaW9uTm9kZScsXG4gIFBBUkFMTEVMX0ZPUksgPSAncGFyYWxsZWxGb3JrTm9kZScsXG4gIFBBUkFMTEVMX0pPSU4gPSAncGFyYWxsZWxKb2luTm9kZScsXG4gIExPT1AgPSAnbG9vcE5vZGUnLFxuICBFUlJPUl9SRVRSWSA9ICdlcnJvclJldHJ5Tm9kZScsXG4gIFRJTUVPVVRfR1VBUkQgPSAndGltZW91dEd1YXJkTm9kZScsXG4gIEhVTUFOX1BBVVNFID0gJ2h1bWFuUGF1c2VOb2RlJyxcbiAgU1VCR1JBUEggPSAnc3ViZ3JhcGhOb2RlJyxcbiAgQ1VTVE9NID0gJ2N1c3RvbU5vZGUnXG59XG5cbi8vIEJhc2ljIG5vZGUgaW50ZXJmYWNlXG5pbnRlcmZhY2UgTm9kZSB7XG4gIGlkOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbiAgcG9zaXRpb246IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcbiAgZGF0YTogeyBsYWJlbDogc3RyaW5nOyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbiAgc2VsZWN0ZWQ/OiBib29sZWFuO1xuICBwYXJlbnROb2RlPzogc3RyaW5nO1xuICB6SW5kZXg/OiBudW1iZXI7XG59XG5cbi8vIEVkZ2UgY29uZGl0aW9uIHR5cGVzIGVudW0gZm9yIGltcHJvdmVkIHR5cGUgc2FmZXR5XG5leHBvcnQgZW51bSBFZGdlQ29uZGl0aW9uIHtcbiAgQUxXQVlTID0gJ2Fsd2F5cycsXG4gIFNVQ0NFU1MgPSAnc3VjY2VzcycsXG4gIEZBSUxVUkUgPSAnZmFpbHVyZScsXG4gIENVU1RPTSA9ICdjdXN0b20nXG59XG5cbi8vIEVuaGFuY2VkIGVkZ2UgaW50ZXJmYWNlIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG5pbnRlcmZhY2UgRWRnZSB7XG4gIGlkOiBzdHJpbmc7XG4gIHNvdXJjZTogc3RyaW5nO1xuICB0YXJnZXQ6IHN0cmluZztcbiAgc291cmNlSGFuZGxlPzogc3RyaW5nO1xuICB0YXJnZXRIYW5kbGU/OiBzdHJpbmc7XG4gIGFuaW1hdGVkPzogYm9vbGVhbjtcbiAgc3R5bGU/OiBhbnk7XG4gIGxhYmVsPzogc3RyaW5nO1xuICBkYXRhPzoge1xuICAgIGNvbmRpdGlvbj86IEVkZ2VDb25kaXRpb247XG4gICAgY3VzdG9tQ29uZGl0aW9uPzogc3RyaW5nO1xuICAgIGJyYW5jaD86IHN0cmluZztcbiAgICBwcmlvcml0eT86IG51bWJlcjtcbiAgICBwYXJhbGxlbEJyYW5jaD86IGJvb2xlYW47XG4gICAgaXNSZXRyeUVkZ2U/OiBib29sZWFuO1xuICB9O1xuICBzZWxlY3RlZD86IGJvb2xlYW47XG59XG5cbi8vIEVycm9yIG1lc3NhZ2VzIGZvciB2YWxpZGF0aW9uXG5jb25zdCBFUlJPUl9NRVNTQUdFUyA9IHtcbiAgU1RBUlRfTk9ERV9FWElTVFM6ICdBIGdyYXBoIGNhbiBvbmx5IGhhdmUgb25lIFNUQVJUIG5vZGUnLFxuICBJTlZBTElEX0NPTk5FQ1RJT046ICdUaGlzIGNvbm5lY3Rpb24gaXMgbm90IGFsbG93ZWQnLFxuICBTVEFSVF9SRVFVSVJFRDogJ0EgZ3JhcGggbXVzdCBoYXZlIGEgU1RBUlQgbm9kZScsXG4gIFNUQVJUX05PX0lOQ09NSU5HOiAnU1RBUlQgbm9kZXMgY2Fubm90IGhhdmUgaW5jb21pbmcgZWRnZXMnLFxuICBTVEFSVF9PTkVfT1VUR09JTkc6ICdTVEFSVCBub2RlIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBvdXRnb2luZyBlZGdlJyxcbiAgRURHRV9GUk9NX0VORDogJ0VORCBub2RlcyBjYW5ub3QgaGF2ZSBvdXRnb2luZyBlZGdlcycsXG4gIERVUExJQ0FURV9FREdFOiAnVGhpcyBjb25uZWN0aW9uIGFscmVhZHkgZXhpc3RzJyxcbiAgU0VMRl9DT05ORUNUSU9OOiAnQSBub2RlIGNhbm5vdCBjb25uZWN0IHRvIGl0c2VsZicsXG4gIFBBUkFMTEVMX0ZPUktfTUlOX0VER0VTOiAnUGFyYWxsZWwgRm9yayBub2RlcyBtdXN0IGhhdmUgYXQgbGVhc3QgMiBvdXRnb2luZyBlZGdlcycsXG4gIFBBUkFMTEVMX0pPSU5fTUlOX0VER0VTOiAnUGFyYWxsZWwgSm9pbiBub2RlcyBtdXN0IGhhdmUgYXQgbGVhc3QgMiBpbmNvbWluZyBlZGdlcycsXG4gIExPT1BfQ1lDTEVfUkVRVUlSRUQ6ICdMb29wIG5vZGVzIG11c3QgaGF2ZSBhIGN5Y2xlJyxcbn07XG5cbmludGVyZmFjZSBHcmFwaFN0YXRlIHtcbiAgLy8gR3JhcGggZGF0YVxuICBub2RlczogTm9kZVtdO1xuICBlZGdlczogRWRnZVtdO1xuICBzZWxlY3RlZE5vZGVJZDogc3RyaW5nIHwgbnVsbDtcbiAgc2VsZWN0ZWRFZGdlSWQ6IHN0cmluZyB8IG51bGw7XG4gIGdyYXBoTmFtZTogc3RyaW5nO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDsgLy8gRm9yIHN0b3JpbmcgdmFsaWRhdGlvbiBlcnJvcnNcbiAgaXNWYWxpZDogYm9vbGVhbjsgLy8gRmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBncmFwaCBpcyB2YWxpZFxuICBcbiAgLy8gQWN0aW9uc1xuICBzZXROb2RlczogKG5vZGVzOiBOb2RlW10pID0+IHZvaWQ7XG4gIHNldEVkZ2VzOiAoZWRnZXM6IEVkZ2VbXSkgPT4gdm9pZDtcbiAgYWRkTm9kZTogKG5vZGU6IE5vZGUpID0+IHZvaWQ7XG4gIHVwZGF0ZU5vZGU6IChpZDogc3RyaW5nLCBkYXRhOiBQYXJ0aWFsPE5vZGU+KSA9PiB2b2lkO1xuICByZW1vdmVOb2RlOiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgY2FuQWRkRWRnZTogKHNvdXJjZTogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZykgPT4geyB2YWxpZDogYm9vbGVhbjsgbWVzc2FnZT86IHN0cmluZyB9O1xuICBhZGRFZGdlOiAoZWRnZTogRWRnZSkgPT4gdm9pZDtcbiAgdXBkYXRlRWRnZTogKGlkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8RWRnZT4pID0+IHZvaWQ7XG4gIHJlbW92ZUVkZ2U6IChpZDogc3RyaW5nKSA9PiB2b2lkO1xuICBzZXRTZWxlY3RlZE5vZGVJZDogKGlkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRTZWxlY3RlZEVkZ2VJZDogKGlkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRHcmFwaE5hbWU6IChuYW1lOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGNsZWFyR3JhcGg6ICgpID0+IHZvaWQ7XG4gIHZhbGlkYXRlR3JhcGg6ICgpID0+IHsgdmFsaWQ6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmcgfTtcbiAgc2V0RXJyb3I6IChlcnJvcjogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbiAgXG4gIC8vIE5vZGUgdHlwZSBzcGVjaWZpYyBhY3Rpb25zXG4gIGFkZERlY2lzaW9uQnJhbmNoOiAobm9kZUlkOiBzdHJpbmcsIGJyYW5jaE5hbWU6IHN0cmluZykgPT4gdm9pZDtcbiAgcmVtb3ZlRGVjaXNpb25CcmFuY2g6IChub2RlSWQ6IHN0cmluZywgYnJhbmNoSW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbiAgYWRkTG9vcEN5Y2xlOiAobG9vcE5vZGVJZDogc3RyaW5nLCB0YXJnZXROb2RlSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgc2V0Tm9kZVBhcmVudDogKG5vZGVJZDogc3RyaW5nLCBwYXJlbnRJZDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbn1cblxuLy8gQ3JlYXRlIHRoZSBzdG9yZVxuZXhwb3J0IGNvbnN0IHVzZUdyYXBoU3RvcmUgPSBjcmVhdGU8R3JhcGhTdGF0ZT4oKShcbiAgcGVyc2lzdChcbiAgICAoc2V0LCBnZXQpID0+ICh7XG4gICAgICAvLyBJbml0aWFsIHN0YXRlXG4gICAgICBub2RlczogW10sXG4gICAgICBlZGdlczogW10sXG4gICAgICBzZWxlY3RlZE5vZGVJZDogbnVsbCxcbiAgICAgIHNlbGVjdGVkRWRnZUlkOiBudWxsLFxuICAgICAgZ3JhcGhOYW1lOiAnVW50aXRsZWQgR3JhcGgnLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgXG4gICAgICAvLyBBY3Rpb25zXG4gICAgICBzZXROb2RlczogKG5vZGVzKSA9PiBzZXQoeyBub2RlcyB9KSxcbiAgICAgIHNldEVkZ2VzOiAoZWRnZXMpID0+IHNldCh7IGVkZ2VzIH0pLFxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSBhbmQgYWRkIGEgbmV3IG5vZGVcbiAgICAgIGFkZE5vZGU6IChub2RlKSA9PiB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFkZGluZyBhIFNUQVJUIG5vZGUgd2hlbiBvbmUgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gTm9kZVR5cGUuU1RBUlQgJiYgXG4gICAgICAgICAgICBnZXQoKS5ub2Rlcy5zb21lKG4gPT4gbi50eXBlID09PSBOb2RlVHlwZS5TVEFSVCkpIHtcbiAgICAgICAgICBzZXQoeyBlcnJvcjogRVJST1JfTUVTU0FHRVMuU1RBUlRfTk9ERV9FWElTVFMgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzZXQoKHN0YXRlKSA9PiAoeyBcbiAgICAgICAgICBub2RlczogWy4uLnN0YXRlLm5vZGVzLCBub2RlXSxcbiAgICAgICAgICBlcnJvcjogbnVsbCwgLy8gQ2xlYXIgYW55IHByZXZpb3VzIGVycm9yc1xuICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXZhbGlkYXRlIHRoZSBncmFwaCBhZnRlciBhZGRpbmcgYSBub2RlXG4gICAgICAgIGNvbnN0IHsgdmFsaWQsIG1lc3NhZ2UgfSA9IGdldCgpLnZhbGlkYXRlR3JhcGgoKTtcbiAgICAgICAgc2V0KHsgaXNWYWxpZDogdmFsaWQsIGVycm9yOiB2YWxpZCA/IG51bGwgOiBtZXNzYWdlIHx8IG51bGwgfSk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBVcGRhdGUgbm9kZSBkYXRhXG4gICAgICB1cGRhdGVOb2RlOiAoaWQsIGRhdGEpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZE5vZGVzID0gc3RhdGUubm9kZXMubWFwKChub2RlKSA9PlxuICAgICAgICAgIG5vZGUuaWQgPT09IGlkID8geyAuLi5ub2RlLCAuLi5kYXRhIH0gOiBub2RlXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXZhbGlkYXRlIHRoZSBncmFwaCBhZnRlciB1cGRhdGluZyBhIG5vZGVcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7IG5vZGVzOiB1cGRhdGVkTm9kZXMgfTtcbiAgICAgICAgY29uc3QgeyB2YWxpZCwgbWVzc2FnZSB9ID0gZ2V0KCkudmFsaWRhdGVHcmFwaCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICAgIGlzVmFsaWQ6IHZhbGlkLFxuICAgICAgICAgIGVycm9yOiB2YWxpZCA/IG51bGwgOiBtZXNzYWdlIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgYSBub2RlIGFuZCBhbGwgY29ubmVjdGVkIGVkZ2VzXG4gICAgICByZW1vdmVOb2RlOiAoaWQpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgbm9kZXM6IHN0YXRlLm5vZGVzLmZpbHRlcigobm9kZSkgPT4gbm9kZS5pZCAhPT0gaWQpLFxuICAgICAgICAgIGVkZ2VzOiBzdGF0ZS5lZGdlcy5maWx0ZXIoXG4gICAgICAgICAgICAoZWRnZSkgPT4gZWRnZS5zb3VyY2UgIT09IGlkICYmIGVkZ2UudGFyZ2V0ICE9PSBpZFxuICAgICAgICAgICksXG4gICAgICAgICAgLy8gQ2xlYXIgc2VsZWN0aW9uIGlmIHRoZSByZW1vdmVkIG5vZGUgd2FzIHNlbGVjdGVkXG4gICAgICAgICAgc2VsZWN0ZWROb2RlSWQ6IHN0YXRlLnNlbGVjdGVkTm9kZUlkID09PSBpZCA/IG51bGwgOiBzdGF0ZS5zZWxlY3RlZE5vZGVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJldmFsaWRhdGUgdGhlIGdyYXBoIGFmdGVyIHJlbW92aW5nIGEgbm9kZVxuICAgICAgICBjb25zdCB7IHZhbGlkLCBtZXNzYWdlIH0gPSBnZXQoKS52YWxpZGF0ZUdyYXBoKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgICAgaXNWYWxpZDogdmFsaWQsXG4gICAgICAgICAgZXJyb3I6IHZhbGlkID8gbnVsbCA6IG1lc3NhZ2UgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIGVkZ2UgYmVmb3JlIGFkZGluZ1xuICAgICAgY2FuQWRkRWRnZTogKHNvdXJjZSwgdGFyZ2V0KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzdGF0ZS5ub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gc291cmNlKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHN0YXRlLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSB0YXJnZXQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFzb3VyY2VOb2RlIHx8ICF0YXJnZXROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiAnU291cmNlIG9yIHRhcmdldCBub2RlIG5vdCBmb3VuZCcgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU2VsZi1jb25uZWN0aW9ucyBhcmUgbm90IGFsbG93ZWRcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5TRUxGX0NPTk5FQ1RJT04gfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRU5EIG5vZGVzIGNhbm5vdCBoYXZlIG91dGdvaW5nIGVkZ2VzXG4gICAgICAgIGlmIChzb3VyY2VOb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVORCkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuRURHRV9GUk9NX0VORCB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGVkZ2UgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKHN0YXRlLmVkZ2VzLnNvbWUoZSA9PiBlLnNvdXJjZSA9PT0gc291cmNlICYmIGUudGFyZ2V0ID09PSB0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5EVVBMSUNBVEVfRURHRSB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayB0eXBlLXNwZWNpZmljIGNvbm5lY3Rpb24gcnVsZXNcbiAgICAgICAgaWYgKCF2YWxpZGF0ZUVkZ2VDb25uZWN0aW9uKHNvdXJjZU5vZGUudHlwZSwgdGFyZ2V0Tm9kZS50eXBlKSkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuSU5WQUxJRF9DT05ORUNUSU9OIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBBZGQgZWRnZSB3aXRoIHZhbGlkYXRpb25cbiAgICAgIGFkZEVkZ2U6IChlZGdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdmFsaWQsIG1lc3NhZ2UgfSA9IGdldCgpLmNhbkFkZEVkZ2UoZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICBzZXQoeyBlcnJvcjogbWVzc2FnZSB8fCBFUlJPUl9NRVNTQUdFUy5JTlZBTElEX0NPTk5FQ1RJT04gfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgIGVkZ2VzOiBbLi4uc3RhdGUuZWRnZXMsIGVkZ2VdLFxuICAgICAgICAgIGVycm9yOiBudWxsLCAvLyBDbGVhciBhbnkgcHJldmlvdXMgZXJyb3JzXG4gICAgICAgIH0pKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJldmFsaWRhdGUgdGhlIGdyYXBoIGFmdGVyIGFkZGluZyBhbiBlZGdlXG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBnZXQoKS52YWxpZGF0ZUdyYXBoKCk7XG4gICAgICAgIHNldCh7IFxuICAgICAgICAgIGlzVmFsaWQ6IHZhbGlkYXRpb25SZXN1bHQudmFsaWQsIFxuICAgICAgICAgIGVycm9yOiB2YWxpZGF0aW9uUmVzdWx0LnZhbGlkID8gbnVsbCA6IHZhbGlkYXRpb25SZXN1bHQubWVzc2FnZSB8fCBudWxsIFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBlZGdlIGRhdGFcbiAgICAgIHVwZGF0ZUVkZ2U6IChpZCwgZGF0YSkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRWRnZXMgPSBzdGF0ZS5lZGdlcy5tYXAoKGVkZ2UpID0+XG4gICAgICAgICAgZWRnZS5pZCA9PT0gaWQgPyB7IC4uLmVkZ2UsIC4uLmRhdGEgfSA6IGVkZ2VcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IGVkZ2VzOiB1cGRhdGVkRWRnZXMgfTtcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgYW4gZWRnZVxuICAgICAgcmVtb3ZlRWRnZTogKGlkKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgICAgIGVkZ2VzOiBzdGF0ZS5lZGdlcy5maWx0ZXIoKGVkZ2UpID0+IGVkZ2UuaWQgIT09IGlkKSxcbiAgICAgICAgICAvLyBDbGVhciBzZWxlY3Rpb24gaWYgdGhlIHJlbW92ZWQgZWRnZSB3YXMgc2VsZWN0ZWRcbiAgICAgICAgICBzZWxlY3RlZEVkZ2VJZDogc3RhdGUuc2VsZWN0ZWRFZGdlSWQgPT09IGlkID8gbnVsbCA6IHN0YXRlLnNlbGVjdGVkRWRnZUlkLFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gUmV2YWxpZGF0ZSB0aGUgZ3JhcGggYWZ0ZXIgcmVtb3ZpbmcgYW4gZWRnZVxuICAgICAgICBjb25zdCB7IHZhbGlkLCBtZXNzYWdlIH0gPSBnZXQoKS52YWxpZGF0ZUdyYXBoKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgICAgaXNWYWxpZDogdmFsaWQsXG4gICAgICAgICAgZXJyb3I6IHZhbGlkID8gbnVsbCA6IG1lc3NhZ2UgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFNldCBzZWxlY3RlZCBub2RlIElEXG4gICAgICBzZXRTZWxlY3RlZE5vZGVJZDogKGlkKSA9PiBzZXQoe1xuICAgICAgICBzZWxlY3RlZE5vZGVJZDogaWQsXG4gICAgICAgIC8vIERlc2VsZWN0IGVkZ2Ugd2hlbiBzZWxlY3RpbmcgYSBub2RlXG4gICAgICAgIHNlbGVjdGVkRWRnZUlkOiBudWxsLFxuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFNldCBzZWxlY3RlZCBlZGdlIElEXG4gICAgICBzZXRTZWxlY3RlZEVkZ2VJZDogKGlkKSA9PiBzZXQoe1xuICAgICAgICBzZWxlY3RlZEVkZ2VJZDogaWQsXG4gICAgICAgIC8vIERlc2VsZWN0IG5vZGUgd2hlbiBzZWxlY3RpbmcgYW4gZWRnZVxuICAgICAgICBzZWxlY3RlZE5vZGVJZDogbnVsbCxcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBTZXQgZ3JhcGggbmFtZVxuICAgICAgc2V0R3JhcGhOYW1lOiAoZ3JhcGhOYW1lKSA9PiBzZXQoeyBncmFwaE5hbWUgfSksXG4gICAgICBcbiAgICAgIC8vIENsZWFyIHRoZSBlbnRpcmUgZ3JhcGhcbiAgICAgIGNsZWFyR3JhcGg6ICgpID0+IHNldCh7XG4gICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgZWRnZXM6IFtdLFxuICAgICAgICBzZWxlY3RlZE5vZGVJZDogbnVsbCxcbiAgICAgICAgc2VsZWN0ZWRFZGdlSWQ6IG51bGwsXG4gICAgICAgIGdyYXBoTmFtZTogJ1VudGl0bGVkIEdyYXBoJyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgdGhlIGVudGlyZSBncmFwaFxuICAgICAgdmFsaWRhdGVHcmFwaDogKCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBleGFjdGx5IG9uZSBTVEFSVCBub2RlXG4gICAgICAgIGNvbnN0IHN0YXJ0Tm9kZXMgPSBzdGF0ZS5ub2Rlcy5maWx0ZXIobiA9PiBuLnR5cGUgPT09IE5vZGVUeXBlLlNUQVJUKTtcbiAgICAgICAgaWYgKHN0YXJ0Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5TVEFSVF9SRVFVSVJFRCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLlNUQVJUX05PREVfRVhJU1RTIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYXRlIFNUQVJUIG5vZGUgaGFzIGV4YWN0bHkgb25lIG91dGdvaW5nIGVkZ2UgYW5kIG5vIGluY29taW5nIGVkZ2VzXG4gICAgICAgIGNvbnN0IHN0YXJ0Tm9kZUlkID0gc3RhcnROb2Rlc1swXS5pZDtcbiAgICAgICAgY29uc3Qgc3RhcnROb2RlT3V0Z29pbmdFZGdlcyA9IHN0YXRlLmVkZ2VzLmZpbHRlcihlID0+IGUuc291cmNlID09PSBzdGFydE5vZGVJZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0Tm9kZUluY29taW5nRWRnZXMgPSBzdGF0ZS5lZGdlcy5maWx0ZXIoZSA9PiBlLnRhcmdldCA9PT0gc3RhcnROb2RlSWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN0YXJ0Tm9kZU91dGdvaW5nRWRnZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5TVEFSVF9PTkVfT1VUR09JTkcgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHN0YXJ0Tm9kZUluY29taW5nRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuU1RBUlRfTk9fSU5DT01JTkcgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVmFsaWRhdGUgbm8gb3V0Z29pbmcgZWRnZXMgZnJvbSBFTkQgbm9kZXNcbiAgICAgICAgY29uc3QgZW5kTm9kZUlkcyA9IHN0YXRlLm5vZGVzXG4gICAgICAgICAgLmZpbHRlcihuID0+IG4udHlwZSA9PT0gTm9kZVR5cGUuRU5EKVxuICAgICAgICAgIC5tYXAobiA9PiBuLmlkKTtcbiAgICAgICAgICBcbiAgICAgICAgY29uc3QgZW5kTm9kZU91dGdvaW5nRWRnZXMgPSBzdGF0ZS5lZGdlcy5maWx0ZXIoZSA9PiBlbmROb2RlSWRzLmluY2x1ZGVzKGUuc291cmNlKSk7XG4gICAgICAgIGlmIChlbmROb2RlT3V0Z29pbmdFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5FREdFX0ZST01fRU5EIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYXRlIFBhcmFsbGVsIEZvcmsgbm9kZXMgaGF2ZSBhdCBsZWFzdCAyIG91dGdvaW5nIGVkZ2VzXG4gICAgICAgIGNvbnN0IHBhcmFsbGVsRm9ya05vZGVzID0gc3RhdGUubm9kZXMuZmlsdGVyKG4gPT4gbi50eXBlID09PSBOb2RlVHlwZS5QQVJBTExFTF9GT1JLKTtcbiAgICAgICAgZm9yIChjb25zdCBmb3JrTm9kZSBvZiBwYXJhbGxlbEZvcmtOb2Rlcykge1xuICAgICAgICAgIGNvbnN0IG91dGdvaW5nRWRnZXMgPSBzdGF0ZS5lZGdlcy5maWx0ZXIoZSA9PiBlLnNvdXJjZSA9PT0gZm9ya05vZGUuaWQpO1xuICAgICAgICAgIGlmIChvdXRnb2luZ0VkZ2VzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuUEFSQUxMRUxfRk9SS19NSU5fRURHRVMgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYXRlIFBhcmFsbGVsIEpvaW4gbm9kZXMgaGF2ZSBhdCBsZWFzdCAyIGluY29taW5nIGVkZ2VzXG4gICAgICAgIGNvbnN0IHBhcmFsbGVsSm9pbk5vZGVzID0gc3RhdGUubm9kZXMuZmlsdGVyKG4gPT4gbi50eXBlID09PSBOb2RlVHlwZS5QQVJBTExFTF9KT0lOKTtcbiAgICAgICAgZm9yIChjb25zdCBqb2luTm9kZSBvZiBwYXJhbGxlbEpvaW5Ob2Rlcykge1xuICAgICAgICAgIGNvbnN0IGluY29taW5nRWRnZXMgPSBzdGF0ZS5lZGdlcy5maWx0ZXIoZSA9PiBlLnRhcmdldCA9PT0gam9pbk5vZGUuaWQpO1xuICAgICAgICAgIGlmIChpbmNvbWluZ0VkZ2VzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuUEFSQUxMRUxfSk9JTl9NSU5fRURHRVMgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYXRlIExvb3Agbm9kZXMgaGF2ZSBhdCBsZWFzdCBvbmUgY3ljbGVcbiAgICAgICAgY29uc3QgbG9vcE5vZGVzID0gc3RhdGUubm9kZXMuZmlsdGVyKG4gPT4gbi50eXBlID09PSBOb2RlVHlwZS5MT09QKTtcbiAgICAgICAgZm9yIChjb25zdCBsb29wTm9kZSBvZiBsb29wTm9kZXMpIHtcbiAgICAgICAgICAvLyBGaW5kIGlmIHRoZXJlJ3MgYSBwYXRoIGJhY2sgdG8gdGhpcyBsb29wIG5vZGVcbiAgICAgICAgICBjb25zdCBoYXNDeWNsZSA9IGhhc0N5Y2xlVG9Ob2RlKGxvb3BOb2RlLmlkLCBzdGF0ZS5lZGdlcyk7XG4gICAgICAgICAgaWYgKCFoYXNDeWNsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5MT09QX0NZQ0xFX1JFUVVJUkVEIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgLy8gU2V0IGVycm9yIG1lc3NhZ2VcbiAgICAgIHNldEVycm9yOiAoZXJyb3IpID0+IHNldCh7IGVycm9yIH0pLFxuICAgICAgXG4gICAgICAvLyBBZGQgYSBuZXcgYnJhbmNoIHRvIGEgZGVjaXNpb24gbm9kZVxuICAgICAgYWRkRGVjaXNpb25CcmFuY2g6IChub2RlSWQsIGJyYW5jaE5hbWUpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXRlLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSBub2RlSWQpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS50eXBlICE9PSBOb2RlVHlwZS5ERUNJU0lPTikgcmV0dXJuIHN0YXRlO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBub2RlJ3MgYnJhbmNoZXMgYXJyYXlcbiAgICAgICAgY29uc3QgdXBkYXRlZE5vZGVzID0gc3RhdGUubm9kZXMubWFwKG4gPT4ge1xuICAgICAgICAgIGlmIChuLmlkID09PSBub2RlSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCcmFuY2hlcyA9IG4uZGF0YS5icmFuY2hlcyB8fCBbXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLm4sXG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAuLi5uLmRhdGEsXG4gICAgICAgICAgICAgICAgYnJhbmNoZXM6IFsuLi5jdXJyZW50QnJhbmNoZXMsIGJyYW5jaE5hbWVdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IG5vZGVzOiB1cGRhdGVkTm9kZXMgfTtcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgYSBicmFuY2ggZnJvbSBhIGRlY2lzaW9uIG5vZGVcbiAgICAgIHJlbW92ZURlY2lzaW9uQnJhbmNoOiAobm9kZUlkLCBicmFuY2hJbmRleCkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gc3RhdGUubm9kZXMuZmluZChuID0+IG4uaWQgPT09IG5vZGVJZCk7XG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLnR5cGUgIT09IE5vZGVUeXBlLkRFQ0lTSU9OKSByZXR1cm4gc3RhdGU7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgdGhlIG5vZGUncyBicmFuY2hlcyBhcnJheVxuICAgICAgICBjb25zdCB1cGRhdGVkTm9kZXMgPSBzdGF0ZS5ub2Rlcy5tYXAobiA9PiB7XG4gICAgICAgICAgaWYgKG4uaWQgPT09IG5vZGVJZCAmJiBuLmRhdGEuYnJhbmNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJyYW5jaGVzID0gWy4uLm4uZGF0YS5icmFuY2hlc107XG4gICAgICAgICAgICBicmFuY2hlcy5zcGxpY2UoYnJhbmNoSW5kZXgsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ubixcbiAgICAgICAgICAgICAgZGF0YTogeyAuLi5uLmRhdGEsIGJyYW5jaGVzIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IG5vZGVzOiB1cGRhdGVkTm9kZXMgfTtcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBBZGQgYSBjeWNsZSBjb25uZWN0aW9uIGZvciBhIGxvb3Agbm9kZVxuICAgICAgYWRkTG9vcEN5Y2xlOiAobG9vcE5vZGVJZCwgdGFyZ2V0Tm9kZUlkKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBlZGdlIGZyb20gdGFyZ2V0IHRvIGxvb3Agbm9kZSB0byBjcmVhdGUgYSBjeWNsZVxuICAgICAgICBjb25zdCBuZXdFZGdlOiBFZGdlID0ge1xuICAgICAgICAgIGlkOiBgZWRnZS0ke2xvb3BOb2RlSWR9LSR7dGFyZ2V0Tm9kZUlkfS1jeWNsZWAsXG4gICAgICAgICAgc291cmNlOiB0YXJnZXROb2RlSWQsXG4gICAgICAgICAgdGFyZ2V0OiBsb29wTm9kZUlkLFxuICAgICAgICAgIGFuaW1hdGVkOiB0cnVlLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGNvbmRpdGlvbjogRWRnZUNvbmRpdGlvbi5BTFdBWVMsXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgZWRnZXM6IFsuLi5zdGF0ZS5lZGdlcywgbmV3RWRnZV0gfTtcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBTZXQgYSBub2RlJ3MgcGFyZW50IChmb3Igc3ViZ3JhcGhzKVxuICAgICAgc2V0Tm9kZVBhcmVudDogKG5vZGVJZCwgcGFyZW50SWQpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZE5vZGVzID0gc3RhdGUubm9kZXMubWFwKG4gPT4ge1xuICAgICAgICAgIGlmIChuLmlkID09PSBub2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLm4sXG4gICAgICAgICAgICAgIHBhcmVudE5vZGU6IHBhcmVudElkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgLy8gSW5jcmVhc2UgekluZGV4IHdoZW4gbm9kZSBpcyBuZXN0ZWRcbiAgICAgICAgICAgICAgekluZGV4OiBwYXJlbnRJZCA/IDEwIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBub2RlczogdXBkYXRlZE5vZGVzIH07XG4gICAgICB9KSxcbiAgICB9KSxcbiAgICB7XG4gICAgICBuYW1lOiAnbGFuZ2dyYXBoLXN0b3JhZ2UnLFxuICAgIH1cbiAgKVxuKTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlR3JhcGhTdG9yZTtcblxuLy8gQ3VzdG9tIGhvb2sgdG8gYWNjZXNzIGdyYXBoIGRhdGEgY29udmVuaWVudGx5XG5leHBvcnQgY29uc3QgdXNlR3JhcGggPSAoKSA9PiB7XG4gIGNvbnN0IG5vZGVzID0gdXNlR3JhcGhTdG9yZShzdGF0ZSA9PiBzdGF0ZS5ub2Rlcyk7XG4gIGNvbnN0IGVkZ2VzID0gdXNlR3JhcGhTdG9yZShzdGF0ZSA9PiBzdGF0ZS5lZGdlcyk7XG4gIGNvbnN0IGdyYXBoTmFtZSA9IHVzZUdyYXBoU3RvcmUoc3RhdGUgPT4gc3RhdGUuZ3JhcGhOYW1lKTtcbiAgcmV0dXJuIHsgbm9kZXMsIGVkZ2VzLCBncmFwaE5hbWUgfTtcbn07XG4iXSwibmFtZXMiOlsiY3JlYXRlIiwicGVyc2lzdCIsInZhbGlkYXRlRWRnZUNvbm5lY3Rpb24iLCJoYXNDeWNsZVRvTm9kZSIsInRhcmdldE5vZGVJZCIsImVkZ2VzIiwidmlzaXRlZCIsIlNldCIsInBhdGgiLCJjdXJyZW50Tm9kZSIsInNvdXJjZXNUb1RhcmdldCIsImZpbHRlciIsImUiLCJ0YXJnZXQiLCJtYXAiLCJzb3VyY2UiLCJoYXMiLCJhZGQiLCJvdXRnb2luZ0VkZ2VzIiwiZWRnZSIsImRlbGV0ZSIsIk5vZGVUeXBlIiwiRWRnZUNvbmRpdGlvbiIsIkVSUk9SX01FU1NBR0VTIiwiU1RBUlRfTk9ERV9FWElTVFMiLCJJTlZBTElEX0NPTk5FQ1RJT04iLCJTVEFSVF9SRVFVSVJFRCIsIlNUQVJUX05PX0lOQ09NSU5HIiwiU1RBUlRfT05FX09VVEdPSU5HIiwiRURHRV9GUk9NX0VORCIsIkRVUExJQ0FURV9FREdFIiwiU0VMRl9DT05ORUNUSU9OIiwiUEFSQUxMRUxfRk9SS19NSU5fRURHRVMiLCJQQVJBTExFTF9KT0lOX01JTl9FREdFUyIsIkxPT1BfQ1lDTEVfUkVRVUlSRUQiLCJ1c2VHcmFwaFN0b3JlIiwic2V0IiwiZ2V0Iiwibm9kZXMiLCJzZWxlY3RlZE5vZGVJZCIsInNlbGVjdGVkRWRnZUlkIiwiZ3JhcGhOYW1lIiwiZXJyb3IiLCJpc1ZhbGlkIiwic2V0Tm9kZXMiLCJzZXRFZGdlcyIsImFkZE5vZGUiLCJub2RlIiwidHlwZSIsInNvbWUiLCJuIiwic3RhdGUiLCJ2YWxpZCIsIm1lc3NhZ2UiLCJ2YWxpZGF0ZUdyYXBoIiwidXBkYXRlTm9kZSIsImlkIiwiZGF0YSIsInVwZGF0ZWROb2RlcyIsIm5ld1N0YXRlIiwicmVtb3ZlTm9kZSIsImNhbkFkZEVkZ2UiLCJzb3VyY2VOb2RlIiwiZmluZCIsInRhcmdldE5vZGUiLCJhZGRFZGdlIiwidmFsaWRhdGlvblJlc3VsdCIsInVwZGF0ZUVkZ2UiLCJ1cGRhdGVkRWRnZXMiLCJyZW1vdmVFZGdlIiwic2V0U2VsZWN0ZWROb2RlSWQiLCJzZXRTZWxlY3RlZEVkZ2VJZCIsInNldEdyYXBoTmFtZSIsImNsZWFyR3JhcGgiLCJzdGFydE5vZGVzIiwibGVuZ3RoIiwic3RhcnROb2RlSWQiLCJzdGFydE5vZGVPdXRnb2luZ0VkZ2VzIiwic3RhcnROb2RlSW5jb21pbmdFZGdlcyIsImVuZE5vZGVJZHMiLCJlbmROb2RlT3V0Z29pbmdFZGdlcyIsImluY2x1ZGVzIiwicGFyYWxsZWxGb3JrTm9kZXMiLCJmb3JrTm9kZSIsInBhcmFsbGVsSm9pbk5vZGVzIiwiam9pbk5vZGUiLCJpbmNvbWluZ0VkZ2VzIiwibG9vcE5vZGVzIiwibG9vcE5vZGUiLCJoYXNDeWNsZSIsInNldEVycm9yIiwiYWRkRGVjaXNpb25CcmFuY2giLCJub2RlSWQiLCJicmFuY2hOYW1lIiwiY3VycmVudEJyYW5jaGVzIiwiYnJhbmNoZXMiLCJyZW1vdmVEZWNpc2lvbkJyYW5jaCIsImJyYW5jaEluZGV4Iiwic3BsaWNlIiwiYWRkTG9vcEN5Y2xlIiwibG9vcE5vZGVJZCIsIm5ld0VkZ2UiLCJhbmltYXRlZCIsImNvbmRpdGlvbiIsInNldE5vZGVQYXJlbnQiLCJwYXJlbnRJZCIsInBhcmVudE5vZGUiLCJ1bmRlZmluZWQiLCJ6SW5kZXgiLCJuYW1lIiwidXNlR3JhcGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/graphStore.ts\n"));

/***/ })

});