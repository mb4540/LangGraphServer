"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/store/graphStore.ts":
/*!*********************************!*\
  !*** ./src/store/graphStore.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EdgeCondition: function() { return /* binding */ EdgeCondition; },\n/* harmony export */   NodeType: function() { return /* binding */ NodeType; },\n/* harmony export */   useGraph: function() { return /* binding */ useGraph; },\n/* harmony export */   useGraphStore: function() { return /* binding */ useGraphStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var _utils_schemaUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/schemaUtils */ \"(app-pages-browser)/./src/utils/schemaUtils.ts\");\n\n\n\n// Helper function to detect cycles in the graph\n// Used for validating Loop nodes\nfunction hasCycleToNode(targetNodeId, edges) {\n    let visited = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Set(), path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new Set(), currentNode = arguments.length > 4 ? arguments[4] : void 0;\n    // If no current node is specified, we need to check all possible starting points\n    if (!currentNode) {\n        // Get all nodes that have edges targeting our loop node\n        const sourcesToTarget = edges.filter((e)=>e.target === targetNodeId).map((e)=>e.source);\n        // For each potential starting point, check if there's a path back to the target\n        for (const source of sourcesToTarget){\n            if (hasCycleToNode(targetNodeId, edges, new Set(), new Set(), source)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // If we've already visited this node in the current path, we found a cycle\n    if (path.has(currentNode)) {\n        return true;\n    }\n    // If we've already visited this node in another path, no need to check again\n    if (visited.has(currentNode)) {\n        return false;\n    }\n    // Mark the current node as visited and add it to the current path\n    visited.add(currentNode);\n    path.add(currentNode);\n    // Check all outgoing edges from the current node\n    const outgoingEdges = edges.filter((e)=>e.source === currentNode);\n    for (const edge of outgoingEdges){\n        // If we find a direct edge back to our target, we found a cycle\n        if (edge.target === targetNodeId) {\n            return true;\n        }\n        // Otherwise, continue searching from the target of this edge\n        if (hasCycleToNode(targetNodeId, edges, visited, path, edge.target)) {\n            return true;\n        }\n    }\n    // Remove the current node from the path as we backtrack\n    path.delete(currentNode);\n    return false;\n}\nvar NodeType;\n(function(NodeType) {\n    NodeType[\"START\"] = \"startNode\";\n    NodeType[\"END\"] = \"endNode\";\n    NodeType[\"AGENT\"] = \"agentNode\";\n    NodeType[\"TOOL\"] = \"toolNode\";\n    NodeType[\"MEMORY_READ\"] = \"memoryReadNode\";\n    NodeType[\"MEMORY_WRITE\"] = \"memoryWriteNode\";\n    NodeType[\"DECISION\"] = \"decisionNode\";\n    NodeType[\"PARALLEL_FORK\"] = \"parallelForkNode\";\n    NodeType[\"PARALLEL_JOIN\"] = \"parallelJoinNode\";\n    NodeType[\"LOOP\"] = \"loopNode\";\n    NodeType[\"ERROR_RETRY\"] = \"errorRetryNode\";\n    NodeType[\"TIMEOUT_GUARD\"] = \"timeoutGuardNode\";\n    NodeType[\"HUMAN_PAUSE\"] = \"humanPauseNode\";\n    NodeType[\"SUBGRAPH\"] = \"subgraphNode\";\n    NodeType[\"CUSTOM\"] = \"customNode\";\n})(NodeType || (NodeType = {}));\nvar EdgeCondition;\n(function(EdgeCondition) {\n    EdgeCondition[\"ALWAYS\"] = \"always\";\n    EdgeCondition[\"SUCCESS\"] = \"success\";\n    EdgeCondition[\"FAILURE\"] = \"failure\";\n    EdgeCondition[\"CUSTOM\"] = \"custom\";\n})(EdgeCondition || (EdgeCondition = {}));\n// Error messages for validation\nconst ERROR_MESSAGES = {\n    START_NODE_EXISTS: \"A graph can only have one START node\",\n    INVALID_CONNECTION: \"This connection is not allowed\",\n    START_REQUIRED: \"A graph must have a START node\",\n    EDGE_FROM_END: \"END nodes cannot have outgoing edges\",\n    DUPLICATE_EDGE: \"This connection already exists\",\n    SELF_CONNECTION: \"A node cannot connect to itself\",\n    PARALLEL_FORK_MIN_EDGES: \"Parallel Fork nodes must have at least 2 outgoing edges\",\n    PARALLEL_JOIN_MIN_EDGES: \"Parallel Join nodes must have at least 2 incoming edges\",\n    LOOP_CYCLE_REQUIRED: \"Loop nodes must have a cycle\"\n};\n// Create the store\nconst useGraphStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.persist)((set, get)=>({\n        // Initial state\n        nodes: [],\n        edges: [],\n        selectedNodeId: null,\n        selectedEdgeId: null,\n        graphName: \"Untitled Graph\",\n        error: null,\n        isValid: true,\n        // Actions\n        setNodes: (nodes)=>set({\n                nodes\n            }),\n        setEdges: (edges)=>set({\n                edges\n            }),\n        // Validate and add a new node\n        addNode: (node)=>{\n            // Check if we're adding a START node when one already exists\n            if (node.type === \"startNode\" && get().nodes.some((n)=>n.type === \"startNode\")) {\n                set({\n                    error: ERROR_MESSAGES.START_NODE_EXISTS\n                });\n                return;\n            }\n            set((state)=>({\n                    nodes: [\n                        ...state.nodes,\n                        node\n                    ],\n                    error: null\n                }));\n            // Revalidate the graph after adding a node\n            const { valid, message } = get().validateGraph();\n            set({\n                isValid: valid,\n                error: valid ? null : message || null\n            });\n        },\n        // Update node data\n        updateNode: (id, data)=>set((state)=>{\n                const updatedNodes = state.nodes.map((node)=>node.id === id ? {\n                        ...node,\n                        ...data\n                    } : node);\n                // Revalidate the graph after updating a node\n                const newState = {\n                    nodes: updatedNodes\n                };\n                const { valid, message } = get().validateGraph();\n                return {\n                    ...newState,\n                    isValid: valid,\n                    error: valid ? null : message || null\n                };\n            }),\n        // Remove a node and all connected edges\n        removeNode: (id)=>set((state)=>{\n                const newState = {\n                    nodes: state.nodes.filter((node)=>node.id !== id),\n                    edges: state.edges.filter((edge)=>edge.source !== id && edge.target !== id),\n                    // Clear selection if the removed node was selected\n                    selectedNodeId: state.selectedNodeId === id ? null : state.selectedNodeId\n                };\n                // Revalidate the graph after removing a node\n                const { valid, message } = get().validateGraph();\n                return {\n                    ...newState,\n                    isValid: valid,\n                    error: valid ? null : message || null\n                };\n            }),\n        // Validate edge before adding\n        canAddEdge: (source, target)=>{\n            const state = get();\n            const sourceNode = state.nodes.find((n)=>n.id === source);\n            const targetNode = state.nodes.find((n)=>n.id === target);\n            if (!sourceNode || !targetNode) {\n                return {\n                    valid: false,\n                    message: \"Source or target node not found\"\n                };\n            }\n            // Self-connections are not allowed\n            if (source === target) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.SELF_CONNECTION\n                };\n            }\n            // END nodes cannot have outgoing edges\n            if (sourceNode.type === \"endNode\") {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.EDGE_FROM_END\n                };\n            }\n            // Check if this edge already exists\n            if (state.edges.some((e)=>e.source === source && e.target === target)) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.DUPLICATE_EDGE\n                };\n            }\n            // Check type-specific connection rules\n            if (!(0,_utils_schemaUtils__WEBPACK_IMPORTED_MODULE_0__.validateEdgeConnection)(sourceNode.type, targetNode.type)) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.INVALID_CONNECTION\n                };\n            }\n            return {\n                valid: true\n            };\n        },\n        // Add edge with validation\n        addEdge: (edge)=>{\n            const { valid, message } = get().canAddEdge(edge.source, edge.target);\n            if (!valid) {\n                set({\n                    error: message || ERROR_MESSAGES.INVALID_CONNECTION\n                });\n                return;\n            }\n            set((state)=>({\n                    edges: [\n                        ...state.edges,\n                        edge\n                    ],\n                    error: null\n                }));\n            // Revalidate the graph after adding an edge\n            const validationResult = get().validateGraph();\n            set({\n                isValid: validationResult.valid,\n                error: validationResult.valid ? null : validationResult.message || null\n            });\n        },\n        // Update edge data\n        updateEdge: (id, data)=>set((state)=>{\n                const updatedEdges = state.edges.map((edge)=>edge.id === id ? {\n                        ...edge,\n                        ...data\n                    } : edge);\n                return {\n                    edges: updatedEdges\n                };\n            }),\n        // Remove an edge\n        removeEdge: (id)=>set((state)=>{\n                const newState = {\n                    edges: state.edges.filter((edge)=>edge.id !== id),\n                    // Clear selection if the removed edge was selected\n                    selectedEdgeId: state.selectedEdgeId === id ? null : state.selectedEdgeId\n                };\n                // Revalidate the graph after removing an edge\n                const { valid, message } = get().validateGraph();\n                return {\n                    ...newState,\n                    isValid: valid,\n                    error: valid ? null : message || null\n                };\n            }),\n        // Set selected node ID\n        setSelectedNodeId: (id)=>set({\n                selectedNodeId: id,\n                // Deselect edge when selecting a node\n                selectedEdgeId: null\n            }),\n        // Set selected edge ID\n        setSelectedEdgeId: (id)=>set({\n                selectedEdgeId: id,\n                // Deselect node when selecting an edge\n                selectedNodeId: null\n            }),\n        // Set graph name\n        setGraphName: (graphName)=>set({\n                graphName\n            }),\n        // Clear the entire graph\n        clearGraph: ()=>set({\n                nodes: [],\n                edges: [],\n                selectedNodeId: null,\n                selectedEdgeId: null,\n                graphName: \"Untitled Graph\",\n                error: null,\n                isValid: true\n            }),\n        // Validate the entire graph\n        validateGraph: ()=>{\n            const state = get();\n            // Check if there's exactly one START node\n            const startNodes = state.nodes.filter((n)=>n.type === \"startNode\");\n            if (startNodes.length === 0) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_REQUIRED\n                };\n            }\n            if (startNodes.length > 1) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_NODE_EXISTS\n                };\n            }\n            // Validate no outgoing edges from END nodes\n            const endNodeIds = state.nodes.filter((n)=>n.type === \"endNode\").map((n)=>n.id);\n            const endNodeOutgoingEdges = state.edges.filter((e)=>endNodeIds.includes(e.source));\n            if (endNodeOutgoingEdges.length > 0) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.EDGE_FROM_END\n                };\n            }\n            // Validate Parallel Fork nodes have at least 2 outgoing edges\n            const parallelForkNodes = state.nodes.filter((n)=>n.type === \"parallelForkNode\");\n            for (const forkNode of parallelForkNodes){\n                const outgoingEdges = state.edges.filter((e)=>e.source === forkNode.id);\n                if (outgoingEdges.length < 2) {\n                    return {\n                        valid: false,\n                        message: ERROR_MESSAGES.PARALLEL_FORK_MIN_EDGES\n                    };\n                }\n            }\n            // Validate Parallel Join nodes have at least 2 incoming edges\n            const parallelJoinNodes = state.nodes.filter((n)=>n.type === \"parallelJoinNode\");\n            for (const joinNode of parallelJoinNodes){\n                const incomingEdges = state.edges.filter((e)=>e.target === joinNode.id);\n                if (incomingEdges.length < 2) {\n                    return {\n                        valid: false,\n                        message: ERROR_MESSAGES.PARALLEL_JOIN_MIN_EDGES\n                    };\n                }\n            }\n            // Validate Loop nodes have at least one cycle\n            const loopNodes = state.nodes.filter((n)=>n.type === \"loopNode\");\n            for (const loopNode of loopNodes){\n                // Find if there's a path back to this loop node\n                const hasCycle = hasCycleToNode(loopNode.id, state.edges);\n                if (!hasCycle) {\n                    return {\n                        valid: false,\n                        message: ERROR_MESSAGES.LOOP_CYCLE_REQUIRED\n                    };\n                }\n            }\n            return {\n                valid: true\n            };\n        },\n        // Set error message\n        setError: (error)=>set({\n                error\n            }),\n        // Add a new branch to a decision node\n        addDecisionBranch: (nodeId, branchName)=>set((state)=>{\n                const node = state.nodes.find((n)=>n.id === nodeId);\n                if (!node || node.type !== \"decisionNode\") return state;\n                // Update the node's branches array\n                const updatedNodes = state.nodes.map((n)=>{\n                    if (n.id === nodeId) {\n                        const currentBranches = n.data.branches || [];\n                        return {\n                            ...n,\n                            data: {\n                                ...n.data,\n                                branches: [\n                                    ...currentBranches,\n                                    branchName\n                                ]\n                            }\n                        };\n                    }\n                    return n;\n                });\n                return {\n                    nodes: updatedNodes\n                };\n            }),\n        // Remove a branch from a decision node\n        removeDecisionBranch: (nodeId, branchIndex)=>set((state)=>{\n                const node = state.nodes.find((n)=>n.id === nodeId);\n                if (!node || node.type !== \"decisionNode\") return state;\n                // Update the node's branches array\n                const updatedNodes = state.nodes.map((n)=>{\n                    if (n.id === nodeId && n.data.branches) {\n                        const branches = [\n                            ...n.data.branches\n                        ];\n                        branches.splice(branchIndex, 1);\n                        return {\n                            ...n,\n                            data: {\n                                ...n.data,\n                                branches\n                            }\n                        };\n                    }\n                    return n;\n                });\n                return {\n                    nodes: updatedNodes\n                };\n            }),\n        // Add a cycle connection for a loop node\n        addLoopCycle: (loopNodeId, targetNodeId)=>set((state)=>{\n                // Create a new edge from target to loop node to create a cycle\n                const newEdge = {\n                    id: \"edge-\".concat(loopNodeId, \"-\").concat(targetNodeId, \"-cycle\"),\n                    source: targetNodeId,\n                    target: loopNodeId,\n                    animated: true,\n                    data: {\n                        condition: \"always\"\n                    }\n                };\n                return {\n                    edges: [\n                        ...state.edges,\n                        newEdge\n                    ]\n                };\n            }),\n        // Set a node's parent (for subgraphs)\n        setNodeParent: (nodeId, parentId)=>set((state)=>{\n                const updatedNodes = state.nodes.map((n)=>{\n                    if (n.id === nodeId) {\n                        return {\n                            ...n,\n                            parentNode: parentId || undefined,\n                            // Increase zIndex when node is nested\n                            zIndex: parentId ? 10 : undefined\n                        };\n                    }\n                    return n;\n                });\n                return {\n                    nodes: updatedNodes\n                };\n            })\n    }), {\n    name: \"langgraph-storage\"\n}));\n/* harmony default export */ __webpack_exports__[\"default\"] = (useGraphStore);\n// Custom hook to access graph data conveniently\nconst useGraph = ()=>{\n    const nodes = useGraphStore((state)=>state.nodes);\n    const edges = useGraphStore((state)=>state.edges);\n    const graphName = useGraphStore((state)=>state.graphName);\n    return {\n        nodes,\n        edges,\n        graphName\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9ncmFwaFN0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUM7QUFDWTtBQUNnQjtBQUU3RCxnREFBZ0Q7QUFDaEQsaUNBQWlDO0FBQ2pDLFNBQVNHLGVBQWVDLFlBQW9CLEVBQUVDLEtBQWE7UUFBRUMsVUFBQUEsaUVBQXVCLElBQUlDLE9BQU9DLE9BQUFBLGlFQUFvQixJQUFJRCxPQUFPRTtJQUM1SCxpRkFBaUY7SUFDakYsSUFBSSxDQUFDQSxhQUFhO1FBQ2hCLHdEQUF3RDtRQUN4RCxNQUFNQyxrQkFBa0JMLE1BQ3JCTSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBS1QsY0FDekJVLEdBQUcsQ0FBQ0YsQ0FBQUEsSUFBS0EsRUFBRUcsTUFBTTtRQUVwQixnRkFBZ0Y7UUFDaEYsS0FBSyxNQUFNQSxVQUFVTCxnQkFBaUI7WUFDcEMsSUFBSVAsZUFBZUMsY0FBY0MsT0FBTyxJQUFJRSxPQUFPLElBQUlBLE9BQU9RLFNBQVM7Z0JBQ3JFLE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBRUEsMkVBQTJFO0lBQzNFLElBQUlQLEtBQUtRLEdBQUcsQ0FBQ1AsY0FBYztRQUN6QixPQUFPO0lBQ1Q7SUFFQSw2RUFBNkU7SUFDN0UsSUFBSUgsUUFBUVUsR0FBRyxDQUFDUCxjQUFjO1FBQzVCLE9BQU87SUFDVDtJQUVBLGtFQUFrRTtJQUNsRUgsUUFBUVcsR0FBRyxDQUFDUjtJQUNaRCxLQUFLUyxHQUFHLENBQUNSO0lBRVQsaURBQWlEO0lBQ2pELE1BQU1TLGdCQUFnQmIsTUFBTU0sTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFRyxNQUFNLEtBQUtOO0lBQ3JELEtBQUssTUFBTVUsUUFBUUQsY0FBZTtRQUNoQyxnRUFBZ0U7UUFDaEUsSUFBSUMsS0FBS04sTUFBTSxLQUFLVCxjQUFjO1lBQ2hDLE9BQU87UUFDVDtRQUVBLDZEQUE2RDtRQUM3RCxJQUFJRCxlQUFlQyxjQUFjQyxPQUFPQyxTQUFTRSxNQUFNVyxLQUFLTixNQUFNLEdBQUc7WUFDbkUsT0FBTztRQUNUO0lBQ0Y7SUFFQSx3REFBd0Q7SUFDeERMLEtBQUtZLE1BQU0sQ0FBQ1g7SUFFWixPQUFPO0FBQ1Q7O1VBR1lZOzs7Ozs7Ozs7Ozs7Ozs7O0dBQUFBLGFBQUFBOztVQThCQUM7Ozs7O0dBQUFBLGtCQUFBQTtBQTRCWixnQ0FBZ0M7QUFDaEMsTUFBTUMsaUJBQWlCO0lBQ3JCQyxtQkFBbUI7SUFDbkJDLG9CQUFvQjtJQUNwQkMsZ0JBQWdCO0lBQ2hCQyxlQUFlO0lBQ2ZDLGdCQUFnQjtJQUNoQkMsaUJBQWlCO0lBQ2pCQyx5QkFBeUI7SUFDekJDLHlCQUF5QjtJQUN6QkMscUJBQXFCO0FBQ3ZCO0FBb0NBLG1CQUFtQjtBQUNaLE1BQU1DLGdCQUFnQmpDLCtDQUFNQSxHQUNqQ0MsMkRBQU9BLENBQ0wsQ0FBQ2lDLEtBQUtDLE1BQVM7UUFDYixnQkFBZ0I7UUFDaEJDLE9BQU8sRUFBRTtRQUNUL0IsT0FBTyxFQUFFO1FBQ1RnQyxnQkFBZ0I7UUFDaEJDLGdCQUFnQjtRQUNoQkMsV0FBVztRQUNYQyxPQUFPO1FBQ1BDLFNBQVM7UUFFVCxVQUFVO1FBQ1ZDLFVBQVUsQ0FBQ04sUUFBVUYsSUFBSTtnQkFBRUU7WUFBTTtRQUNqQ08sVUFBVSxDQUFDdEMsUUFBVTZCLElBQUk7Z0JBQUU3QjtZQUFNO1FBRWpDLDhCQUE4QjtRQUM5QnVDLFNBQVMsQ0FBQ0M7WUFDUiw2REFBNkQ7WUFDN0QsSUFBSUEsS0FBS0MsSUFBSSxvQkFDVFgsTUFBTUMsS0FBSyxDQUFDVyxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVGLElBQUksbUJBQXNCO2dCQUNwRFosSUFBSTtvQkFBRU0sT0FBT2pCLGVBQWVDLGlCQUFpQjtnQkFBQztnQkFDOUM7WUFDRjtZQUVBVSxJQUFJLENBQUNlLFFBQVc7b0JBQ2RiLE9BQU87MkJBQUlhLE1BQU1iLEtBQUs7d0JBQUVTO3FCQUFLO29CQUM3QkwsT0FBTztnQkFDVDtZQUVBLDJDQUEyQztZQUMzQyxNQUFNLEVBQUVVLEtBQUssRUFBRUMsT0FBTyxFQUFFLEdBQUdoQixNQUFNaUIsYUFBYTtZQUM5Q2xCLElBQUk7Z0JBQUVPLFNBQVNTO2dCQUFPVixPQUFPVSxRQUFRLE9BQU9DLFdBQVc7WUFBSztRQUM5RDtRQUVBLG1CQUFtQjtRQUNuQkUsWUFBWSxDQUFDQyxJQUFJQyxPQUFTckIsSUFBSSxDQUFDZTtnQkFDN0IsTUFBTU8sZUFBZVAsTUFBTWIsS0FBSyxDQUFDdEIsR0FBRyxDQUFDLENBQUMrQixPQUNwQ0EsS0FBS1MsRUFBRSxLQUFLQSxLQUFLO3dCQUFFLEdBQUdULElBQUk7d0JBQUUsR0FBR1UsSUFBSTtvQkFBQyxJQUFJVjtnQkFHMUMsNkNBQTZDO2dCQUM3QyxNQUFNWSxXQUFXO29CQUFFckIsT0FBT29CO2dCQUFhO2dCQUN2QyxNQUFNLEVBQUVOLEtBQUssRUFBRUMsT0FBTyxFQUFFLEdBQUdoQixNQUFNaUIsYUFBYTtnQkFDOUMsT0FBTztvQkFDTCxHQUFHSyxRQUFRO29CQUNYaEIsU0FBU1M7b0JBQ1RWLE9BQU9VLFFBQVEsT0FBT0MsV0FBVztnQkFDbkM7WUFDRjtRQUVBLHdDQUF3QztRQUN4Q08sWUFBWSxDQUFDSixLQUFPcEIsSUFBSSxDQUFDZTtnQkFDdkIsTUFBTVEsV0FBVztvQkFDZnJCLE9BQU9hLE1BQU1iLEtBQUssQ0FBQ3pCLE1BQU0sQ0FBQyxDQUFDa0MsT0FBU0EsS0FBS1MsRUFBRSxLQUFLQTtvQkFDaERqRCxPQUFPNEMsTUFBTTVDLEtBQUssQ0FBQ00sTUFBTSxDQUN2QixDQUFDUSxPQUFTQSxLQUFLSixNQUFNLEtBQUt1QyxNQUFNbkMsS0FBS04sTUFBTSxLQUFLeUM7b0JBRWxELG1EQUFtRDtvQkFDbkRqQixnQkFBZ0JZLE1BQU1aLGNBQWMsS0FBS2lCLEtBQUssT0FBT0wsTUFBTVosY0FBYztnQkFDM0U7Z0JBRUEsNkNBQTZDO2dCQUM3QyxNQUFNLEVBQUVhLEtBQUssRUFBRUMsT0FBTyxFQUFFLEdBQUdoQixNQUFNaUIsYUFBYTtnQkFDOUMsT0FBTztvQkFDTCxHQUFHSyxRQUFRO29CQUNYaEIsU0FBU1M7b0JBQ1RWLE9BQU9VLFFBQVEsT0FBT0MsV0FBVztnQkFDbkM7WUFDRjtRQUVBLDhCQUE4QjtRQUM5QlEsWUFBWSxDQUFDNUMsUUFBUUY7WUFDbkIsTUFBTW9DLFFBQVFkO1lBQ2QsTUFBTXlCLGFBQWFYLE1BQU1iLEtBQUssQ0FBQ3lCLElBQUksQ0FBQ2IsQ0FBQUEsSUFBS0EsRUFBRU0sRUFBRSxLQUFLdkM7WUFDbEQsTUFBTStDLGFBQWFiLE1BQU1iLEtBQUssQ0FBQ3lCLElBQUksQ0FBQ2IsQ0FBQUEsSUFBS0EsRUFBRU0sRUFBRSxLQUFLekM7WUFFbEQsSUFBSSxDQUFDK0MsY0FBYyxDQUFDRSxZQUFZO2dCQUM5QixPQUFPO29CQUFFWixPQUFPO29CQUFPQyxTQUFTO2dCQUFrQztZQUNwRTtZQUVBLG1DQUFtQztZQUNuQyxJQUFJcEMsV0FBV0YsUUFBUTtnQkFDckIsT0FBTztvQkFBRXFDLE9BQU87b0JBQU9DLFNBQVM1QixlQUFlTSxlQUFlO2dCQUFDO1lBQ2pFO1lBRUEsdUNBQXVDO1lBQ3ZDLElBQUkrQixXQUFXZCxJQUFJLGdCQUFtQjtnQkFDcEMsT0FBTztvQkFBRUksT0FBTztvQkFBT0MsU0FBUzVCLGVBQWVJLGFBQWE7Z0JBQUM7WUFDL0Q7WUFFQSxvQ0FBb0M7WUFDcEMsSUFBSXNCLE1BQU01QyxLQUFLLENBQUMwQyxJQUFJLENBQUNuQyxDQUFBQSxJQUFLQSxFQUFFRyxNQUFNLEtBQUtBLFVBQVVILEVBQUVDLE1BQU0sS0FBS0EsU0FBUztnQkFDckUsT0FBTztvQkFBRXFDLE9BQU87b0JBQU9DLFNBQVM1QixlQUFlSyxjQUFjO2dCQUFDO1lBQ2hFO1lBRUEsdUNBQXVDO1lBQ3ZDLElBQUksQ0FBQzFCLDBFQUFzQkEsQ0FBQzBELFdBQVdkLElBQUksRUFBRWdCLFdBQVdoQixJQUFJLEdBQUc7Z0JBQzdELE9BQU87b0JBQUVJLE9BQU87b0JBQU9DLFNBQVM1QixlQUFlRSxrQkFBa0I7Z0JBQUM7WUFDcEU7WUFFQSxPQUFPO2dCQUFFeUIsT0FBTztZQUFLO1FBQ3ZCO1FBRUEsMkJBQTJCO1FBQzNCYSxTQUFTLENBQUM1QztZQUNSLE1BQU0sRUFBRStCLEtBQUssRUFBRUMsT0FBTyxFQUFFLEdBQUdoQixNQUFNd0IsVUFBVSxDQUFDeEMsS0FBS0osTUFBTSxFQUFFSSxLQUFLTixNQUFNO1lBRXBFLElBQUksQ0FBQ3FDLE9BQU87Z0JBQ1ZoQixJQUFJO29CQUFFTSxPQUFPVyxXQUFXNUIsZUFBZUUsa0JBQWtCO2dCQUFDO2dCQUMxRDtZQUNGO1lBRUFTLElBQUksQ0FBQ2UsUUFBVztvQkFDZDVDLE9BQU87MkJBQUk0QyxNQUFNNUMsS0FBSzt3QkFBRWM7cUJBQUs7b0JBQzdCcUIsT0FBTztnQkFDVDtZQUVBLDRDQUE0QztZQUM1QyxNQUFNd0IsbUJBQW1CN0IsTUFBTWlCLGFBQWE7WUFDNUNsQixJQUFJO2dCQUNGTyxTQUFTdUIsaUJBQWlCZCxLQUFLO2dCQUMvQlYsT0FBT3dCLGlCQUFpQmQsS0FBSyxHQUFHLE9BQU9jLGlCQUFpQmIsT0FBTyxJQUFJO1lBQ3JFO1FBQ0Y7UUFFQSxtQkFBbUI7UUFDbkJjLFlBQVksQ0FBQ1gsSUFBSUMsT0FBU3JCLElBQUksQ0FBQ2U7Z0JBQzdCLE1BQU1pQixlQUFlakIsTUFBTTVDLEtBQUssQ0FBQ1MsR0FBRyxDQUFDLENBQUNLLE9BQ3BDQSxLQUFLbUMsRUFBRSxLQUFLQSxLQUFLO3dCQUFFLEdBQUduQyxJQUFJO3dCQUFFLEdBQUdvQyxJQUFJO29CQUFDLElBQUlwQztnQkFHMUMsT0FBTztvQkFBRWQsT0FBTzZEO2dCQUFhO1lBQy9CO1FBRUEsaUJBQWlCO1FBQ2pCQyxZQUFZLENBQUNiLEtBQU9wQixJQUFJLENBQUNlO2dCQUN2QixNQUFNUSxXQUFXO29CQUNmcEQsT0FBTzRDLE1BQU01QyxLQUFLLENBQUNNLE1BQU0sQ0FBQyxDQUFDUSxPQUFTQSxLQUFLbUMsRUFBRSxLQUFLQTtvQkFDaEQsbURBQW1EO29CQUNuRGhCLGdCQUFnQlcsTUFBTVgsY0FBYyxLQUFLZ0IsS0FBSyxPQUFPTCxNQUFNWCxjQUFjO2dCQUMzRTtnQkFFQSw4Q0FBOEM7Z0JBQzlDLE1BQU0sRUFBRVksS0FBSyxFQUFFQyxPQUFPLEVBQUUsR0FBR2hCLE1BQU1pQixhQUFhO2dCQUM5QyxPQUFPO29CQUNMLEdBQUdLLFFBQVE7b0JBQ1hoQixTQUFTUztvQkFDVFYsT0FBT1UsUUFBUSxPQUFPQyxXQUFXO2dCQUNuQztZQUNGO1FBRUEsdUJBQXVCO1FBQ3ZCaUIsbUJBQW1CLENBQUNkLEtBQU9wQixJQUFJO2dCQUM3QkcsZ0JBQWdCaUI7Z0JBQ2hCLHNDQUFzQztnQkFDdENoQixnQkFBZ0I7WUFDbEI7UUFFQSx1QkFBdUI7UUFDdkIrQixtQkFBbUIsQ0FBQ2YsS0FBT3BCLElBQUk7Z0JBQzdCSSxnQkFBZ0JnQjtnQkFDaEIsdUNBQXVDO2dCQUN2Q2pCLGdCQUFnQjtZQUNsQjtRQUVBLGlCQUFpQjtRQUNqQmlDLGNBQWMsQ0FBQy9CLFlBQWNMLElBQUk7Z0JBQUVLO1lBQVU7UUFFN0MseUJBQXlCO1FBQ3pCZ0MsWUFBWSxJQUFNckMsSUFBSTtnQkFDcEJFLE9BQU8sRUFBRTtnQkFDVC9CLE9BQU8sRUFBRTtnQkFDVGdDLGdCQUFnQjtnQkFDaEJDLGdCQUFnQjtnQkFDaEJDLFdBQVc7Z0JBQ1hDLE9BQU87Z0JBQ1BDLFNBQVM7WUFDWDtRQUVBLDRCQUE0QjtRQUM1QlcsZUFBZTtZQUNiLE1BQU1ILFFBQVFkO1lBRWQsMENBQTBDO1lBQzFDLE1BQU1xQyxhQUFhdkIsTUFBTWIsS0FBSyxDQUFDekIsTUFBTSxDQUFDcUMsQ0FBQUEsSUFBS0EsRUFBRUYsSUFBSTtZQUNqRCxJQUFJMEIsV0FBV0MsTUFBTSxLQUFLLEdBQUc7Z0JBQzNCLE9BQU87b0JBQUV2QixPQUFPO29CQUFPQyxTQUFTNUIsZUFBZUcsY0FBYztnQkFBQztZQUNoRTtZQUNBLElBQUk4QyxXQUFXQyxNQUFNLEdBQUcsR0FBRztnQkFDekIsT0FBTztvQkFBRXZCLE9BQU87b0JBQU9DLFNBQVM1QixlQUFlQyxpQkFBaUI7Z0JBQUM7WUFDbkU7WUFFQSw0Q0FBNEM7WUFDNUMsTUFBTWtELGFBQWF6QixNQUFNYixLQUFLLENBQzNCekIsTUFBTSxDQUFDcUMsQ0FBQUEsSUFBS0EsRUFBRUYsSUFBSSxnQkFDbEJoQyxHQUFHLENBQUNrQyxDQUFBQSxJQUFLQSxFQUFFTSxFQUFFO1lBRWhCLE1BQU1xQix1QkFBdUIxQixNQUFNNUMsS0FBSyxDQUFDTSxNQUFNLENBQUNDLENBQUFBLElBQUs4RCxXQUFXRSxRQUFRLENBQUNoRSxFQUFFRyxNQUFNO1lBQ2pGLElBQUk0RCxxQkFBcUJGLE1BQU0sR0FBRyxHQUFHO2dCQUNuQyxPQUFPO29CQUFFdkIsT0FBTztvQkFBT0MsU0FBUzVCLGVBQWVJLGFBQWE7Z0JBQUM7WUFDL0Q7WUFFQSw4REFBOEQ7WUFDOUQsTUFBTWtELG9CQUFvQjVCLE1BQU1iLEtBQUssQ0FBQ3pCLE1BQU0sQ0FBQ3FDLENBQUFBLElBQUtBLEVBQUVGLElBQUk7WUFDeEQsS0FBSyxNQUFNZ0MsWUFBWUQsa0JBQW1CO2dCQUN4QyxNQUFNM0QsZ0JBQWdCK0IsTUFBTTVDLEtBQUssQ0FBQ00sTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFRyxNQUFNLEtBQUsrRCxTQUFTeEIsRUFBRTtnQkFDdEUsSUFBSXBDLGNBQWN1RCxNQUFNLEdBQUcsR0FBRztvQkFDNUIsT0FBTzt3QkFBRXZCLE9BQU87d0JBQU9DLFNBQVM1QixlQUFlTyx1QkFBdUI7b0JBQUM7Z0JBQ3pFO1lBQ0Y7WUFFQSw4REFBOEQ7WUFDOUQsTUFBTWlELG9CQUFvQjlCLE1BQU1iLEtBQUssQ0FBQ3pCLE1BQU0sQ0FBQ3FDLENBQUFBLElBQUtBLEVBQUVGLElBQUk7WUFDeEQsS0FBSyxNQUFNa0MsWUFBWUQsa0JBQW1CO2dCQUN4QyxNQUFNRSxnQkFBZ0JoQyxNQUFNNUMsS0FBSyxDQUFDTSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBS21FLFNBQVMxQixFQUFFO2dCQUN0RSxJQUFJMkIsY0FBY1IsTUFBTSxHQUFHLEdBQUc7b0JBQzVCLE9BQU87d0JBQUV2QixPQUFPO3dCQUFPQyxTQUFTNUIsZUFBZVEsdUJBQXVCO29CQUFDO2dCQUN6RTtZQUNGO1lBRUEsOENBQThDO1lBQzlDLE1BQU1tRCxZQUFZakMsTUFBTWIsS0FBSyxDQUFDekIsTUFBTSxDQUFDcUMsQ0FBQUEsSUFBS0EsRUFBRUYsSUFBSTtZQUNoRCxLQUFLLE1BQU1xQyxZQUFZRCxVQUFXO2dCQUNoQyxnREFBZ0Q7Z0JBQ2hELE1BQU1FLFdBQVdqRixlQUFlZ0YsU0FBUzdCLEVBQUUsRUFBRUwsTUFBTTVDLEtBQUs7Z0JBQ3hELElBQUksQ0FBQytFLFVBQVU7b0JBQ2IsT0FBTzt3QkFBRWxDLE9BQU87d0JBQU9DLFNBQVM1QixlQUFlUyxtQkFBbUI7b0JBQUM7Z0JBQ3JFO1lBQ0Y7WUFFQSxPQUFPO2dCQUFFa0IsT0FBTztZQUFLO1FBQ3ZCO1FBRUEsb0JBQW9CO1FBQ3BCbUMsVUFBVSxDQUFDN0MsUUFBVU4sSUFBSTtnQkFBRU07WUFBTTtRQUVqQyxzQ0FBc0M7UUFDdEM4QyxtQkFBbUIsQ0FBQ0MsUUFBUUMsYUFBZXRELElBQUksQ0FBQ2U7Z0JBQzlDLE1BQU1KLE9BQU9JLE1BQU1iLEtBQUssQ0FBQ3lCLElBQUksQ0FBQ2IsQ0FBQUEsSUFBS0EsRUFBRU0sRUFBRSxLQUFLaUM7Z0JBQzVDLElBQUksQ0FBQzFDLFFBQVFBLEtBQUtDLElBQUkscUJBQXdCLE9BQU9HO2dCQUVyRCxtQ0FBbUM7Z0JBQ25DLE1BQU1PLGVBQWVQLE1BQU1iLEtBQUssQ0FBQ3RCLEdBQUcsQ0FBQ2tDLENBQUFBO29CQUNuQyxJQUFJQSxFQUFFTSxFQUFFLEtBQUtpQyxRQUFRO3dCQUNuQixNQUFNRSxrQkFBa0J6QyxFQUFFTyxJQUFJLENBQUNtQyxRQUFRLElBQUksRUFBRTt3QkFDN0MsT0FBTzs0QkFDTCxHQUFHMUMsQ0FBQzs0QkFDSk8sTUFBTTtnQ0FDSixHQUFHUCxFQUFFTyxJQUFJO2dDQUNUbUMsVUFBVTt1Q0FBSUQ7b0NBQWlCRDtpQ0FBVzs0QkFDNUM7d0JBQ0Y7b0JBQ0Y7b0JBQ0EsT0FBT3hDO2dCQUNUO2dCQUVBLE9BQU87b0JBQUVaLE9BQU9vQjtnQkFBYTtZQUMvQjtRQUVBLHVDQUF1QztRQUN2Q21DLHNCQUFzQixDQUFDSixRQUFRSyxjQUFnQjFELElBQUksQ0FBQ2U7Z0JBQ2xELE1BQU1KLE9BQU9JLE1BQU1iLEtBQUssQ0FBQ3lCLElBQUksQ0FBQ2IsQ0FBQUEsSUFBS0EsRUFBRU0sRUFBRSxLQUFLaUM7Z0JBQzVDLElBQUksQ0FBQzFDLFFBQVFBLEtBQUtDLElBQUkscUJBQXdCLE9BQU9HO2dCQUVyRCxtQ0FBbUM7Z0JBQ25DLE1BQU1PLGVBQWVQLE1BQU1iLEtBQUssQ0FBQ3RCLEdBQUcsQ0FBQ2tDLENBQUFBO29CQUNuQyxJQUFJQSxFQUFFTSxFQUFFLEtBQUtpQyxVQUFVdkMsRUFBRU8sSUFBSSxDQUFDbUMsUUFBUSxFQUFFO3dCQUN0QyxNQUFNQSxXQUFXOytCQUFJMUMsRUFBRU8sSUFBSSxDQUFDbUMsUUFBUTt5QkFBQzt3QkFDckNBLFNBQVNHLE1BQU0sQ0FBQ0QsYUFBYTt3QkFDN0IsT0FBTzs0QkFDTCxHQUFHNUMsQ0FBQzs0QkFDSk8sTUFBTTtnQ0FBRSxHQUFHUCxFQUFFTyxJQUFJO2dDQUFFbUM7NEJBQVM7d0JBQzlCO29CQUNGO29CQUNBLE9BQU8xQztnQkFDVDtnQkFFQSxPQUFPO29CQUFFWixPQUFPb0I7Z0JBQWE7WUFDL0I7UUFFQSx5Q0FBeUM7UUFDekNzQyxjQUFjLENBQUNDLFlBQVkzRixlQUFpQjhCLElBQUksQ0FBQ2U7Z0JBQy9DLCtEQUErRDtnQkFDL0QsTUFBTStDLFVBQWdCO29CQUNwQjFDLElBQUksUUFBc0JsRCxPQUFkMkYsWUFBVyxLQUFnQixPQUFiM0YsY0FBYTtvQkFDdkNXLFFBQVFYO29CQUNSUyxRQUFRa0Y7b0JBQ1JFLFVBQVU7b0JBQ1YxQyxNQUFNO3dCQUNKMkMsU0FBUztvQkFDWDtnQkFDRjtnQkFFQSxPQUFPO29CQUFFN0YsT0FBTzsyQkFBSTRDLE1BQU01QyxLQUFLO3dCQUFFMkY7cUJBQVE7Z0JBQUM7WUFDNUM7UUFFQSxzQ0FBc0M7UUFDdENHLGVBQWUsQ0FBQ1osUUFBUWEsV0FBYWxFLElBQUksQ0FBQ2U7Z0JBQ3hDLE1BQU1PLGVBQWVQLE1BQU1iLEtBQUssQ0FBQ3RCLEdBQUcsQ0FBQ2tDLENBQUFBO29CQUNuQyxJQUFJQSxFQUFFTSxFQUFFLEtBQUtpQyxRQUFRO3dCQUNuQixPQUFPOzRCQUNMLEdBQUd2QyxDQUFDOzRCQUNKcUQsWUFBWUQsWUFBWUU7NEJBQ3hCLHNDQUFzQzs0QkFDdENDLFFBQVFILFdBQVcsS0FBS0U7d0JBQzFCO29CQUNGO29CQUNBLE9BQU90RDtnQkFDVDtnQkFFQSxPQUFPO29CQUFFWixPQUFPb0I7Z0JBQWE7WUFDL0I7SUFDRixJQUNBO0lBQ0VnRCxNQUFNO0FBQ1IsSUFFRjtBQUVGLCtEQUFldkUsYUFBYUEsRUFBQztBQUU3QixnREFBZ0Q7QUFDekMsTUFBTXdFLFdBQVc7SUFDdEIsTUFBTXJFLFFBQVFILGNBQWNnQixDQUFBQSxRQUFTQSxNQUFNYixLQUFLO0lBQ2hELE1BQU0vQixRQUFRNEIsY0FBY2dCLENBQUFBLFFBQVNBLE1BQU01QyxLQUFLO0lBQ2hELE1BQU1rQyxZQUFZTixjQUFjZ0IsQ0FBQUEsUUFBU0EsTUFBTVYsU0FBUztJQUN4RCxPQUFPO1FBQUVIO1FBQU8vQjtRQUFPa0M7SUFBVTtBQUNuQyxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdG9yZS9ncmFwaFN0b3JlLnRzPzRlZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgeyBwZXJzaXN0IH0gZnJvbSAnenVzdGFuZC9taWRkbGV3YXJlJztcbmltcG9ydCB7IHZhbGlkYXRlRWRnZUNvbm5lY3Rpb24gfSBmcm9tICdAL3V0aWxzL3NjaGVtYVV0aWxzJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVjdCBjeWNsZXMgaW4gdGhlIGdyYXBoXG4vLyBVc2VkIGZvciB2YWxpZGF0aW5nIExvb3Agbm9kZXNcbmZ1bmN0aW9uIGhhc0N5Y2xlVG9Ob2RlKHRhcmdldE5vZGVJZDogc3RyaW5nLCBlZGdlczogRWRnZVtdLCB2aXNpdGVkOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKSwgcGF0aDogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCksIGN1cnJlbnROb2RlPzogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIElmIG5vIGN1cnJlbnQgbm9kZSBpcyBzcGVjaWZpZWQsIHdlIG5lZWQgdG8gY2hlY2sgYWxsIHBvc3NpYmxlIHN0YXJ0aW5nIHBvaW50c1xuICBpZiAoIWN1cnJlbnROb2RlKSB7XG4gICAgLy8gR2V0IGFsbCBub2RlcyB0aGF0IGhhdmUgZWRnZXMgdGFyZ2V0aW5nIG91ciBsb29wIG5vZGVcbiAgICBjb25zdCBzb3VyY2VzVG9UYXJnZXQgPSBlZGdlc1xuICAgICAgLmZpbHRlcihlID0+IGUudGFyZ2V0ID09PSB0YXJnZXROb2RlSWQpXG4gICAgICAubWFwKGUgPT4gZS5zb3VyY2UpO1xuICAgIFxuICAgIC8vIEZvciBlYWNoIHBvdGVudGlhbCBzdGFydGluZyBwb2ludCwgY2hlY2sgaWYgdGhlcmUncyBhIHBhdGggYmFjayB0byB0aGUgdGFyZ2V0XG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlc1RvVGFyZ2V0KSB7XG4gICAgICBpZiAoaGFzQ3ljbGVUb05vZGUodGFyZ2V0Tm9kZUlkLCBlZGdlcywgbmV3IFNldCgpLCBuZXcgU2V0KCksIHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgLy8gSWYgd2UndmUgYWxyZWFkeSB2aXNpdGVkIHRoaXMgbm9kZSBpbiB0aGUgY3VycmVudCBwYXRoLCB3ZSBmb3VuZCBhIGN5Y2xlXG4gIGlmIChwYXRoLmhhcyhjdXJyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBcbiAgLy8gSWYgd2UndmUgYWxyZWFkeSB2aXNpdGVkIHRoaXMgbm9kZSBpbiBhbm90aGVyIHBhdGgsIG5vIG5lZWQgdG8gY2hlY2sgYWdhaW5cbiAgaWYgKHZpc2l0ZWQuaGFzKGN1cnJlbnROb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgLy8gTWFyayB0aGUgY3VycmVudCBub2RlIGFzIHZpc2l0ZWQgYW5kIGFkZCBpdCB0byB0aGUgY3VycmVudCBwYXRoXG4gIHZpc2l0ZWQuYWRkKGN1cnJlbnROb2RlKTtcbiAgcGF0aC5hZGQoY3VycmVudE5vZGUpO1xuICBcbiAgLy8gQ2hlY2sgYWxsIG91dGdvaW5nIGVkZ2VzIGZyb20gdGhlIGN1cnJlbnQgbm9kZVxuICBjb25zdCBvdXRnb2luZ0VkZ2VzID0gZWRnZXMuZmlsdGVyKGUgPT4gZS5zb3VyY2UgPT09IGN1cnJlbnROb2RlKTtcbiAgZm9yIChjb25zdCBlZGdlIG9mIG91dGdvaW5nRWRnZXMpIHtcbiAgICAvLyBJZiB3ZSBmaW5kIGEgZGlyZWN0IGVkZ2UgYmFjayB0byBvdXIgdGFyZ2V0LCB3ZSBmb3VuZCBhIGN5Y2xlXG4gICAgaWYgKGVkZ2UudGFyZ2V0ID09PSB0YXJnZXROb2RlSWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBPdGhlcndpc2UsIGNvbnRpbnVlIHNlYXJjaGluZyBmcm9tIHRoZSB0YXJnZXQgb2YgdGhpcyBlZGdlXG4gICAgaWYgKGhhc0N5Y2xlVG9Ob2RlKHRhcmdldE5vZGVJZCwgZWRnZXMsIHZpc2l0ZWQsIHBhdGgsIGVkZ2UudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIFxuICAvLyBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSBmcm9tIHRoZSBwYXRoIGFzIHdlIGJhY2t0cmFja1xuICBwYXRoLmRlbGV0ZShjdXJyZW50Tm9kZSk7XG4gIFxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIE5vZGUgdHlwZXMgZW51bSBmb3IgaW1wcm92ZWQgdHlwZSBzYWZldHlcbmV4cG9ydCBlbnVtIE5vZGVUeXBlIHtcbiAgU1RBUlQgPSAnc3RhcnROb2RlJyxcbiAgRU5EID0gJ2VuZE5vZGUnLFxuICBBR0VOVCA9ICdhZ2VudE5vZGUnLFxuICBUT09MID0gJ3Rvb2xOb2RlJyxcbiAgTUVNT1JZX1JFQUQgPSAnbWVtb3J5UmVhZE5vZGUnLFxuICBNRU1PUllfV1JJVEUgPSAnbWVtb3J5V3JpdGVOb2RlJyxcbiAgREVDSVNJT04gPSAnZGVjaXNpb25Ob2RlJyxcbiAgUEFSQUxMRUxfRk9SSyA9ICdwYXJhbGxlbEZvcmtOb2RlJyxcbiAgUEFSQUxMRUxfSk9JTiA9ICdwYXJhbGxlbEpvaW5Ob2RlJyxcbiAgTE9PUCA9ICdsb29wTm9kZScsXG4gIEVSUk9SX1JFVFJZID0gJ2Vycm9yUmV0cnlOb2RlJyxcbiAgVElNRU9VVF9HVUFSRCA9ICd0aW1lb3V0R3VhcmROb2RlJyxcbiAgSFVNQU5fUEFVU0UgPSAnaHVtYW5QYXVzZU5vZGUnLFxuICBTVUJHUkFQSCA9ICdzdWJncmFwaE5vZGUnLFxuICBDVVNUT00gPSAnY3VzdG9tTm9kZSdcbn1cblxuLy8gQmFzaWMgbm9kZSBpbnRlcmZhY2VcbmludGVyZmFjZSBOb2RlIHtcbiAgaWQ6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xuICBwb3NpdGlvbjogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICBkYXRhOiB7IGxhYmVsOiBzdHJpbmc7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICBzZWxlY3RlZD86IGJvb2xlYW47XG4gIHBhcmVudE5vZGU/OiBzdHJpbmc7XG4gIHpJbmRleD86IG51bWJlcjtcbn1cblxuLy8gRWRnZSBjb25kaXRpb24gdHlwZXMgZW51bSBmb3IgaW1wcm92ZWQgdHlwZSBzYWZldHlcbmV4cG9ydCBlbnVtIEVkZ2VDb25kaXRpb24ge1xuICBBTFdBWVMgPSAnYWx3YXlzJyxcbiAgU1VDQ0VTUyA9ICdzdWNjZXNzJyxcbiAgRkFJTFVSRSA9ICdmYWlsdXJlJyxcbiAgQ1VTVE9NID0gJ2N1c3RvbSdcbn1cblxuLy8gRW5oYW5jZWQgZWRnZSBpbnRlcmZhY2Ugd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbmludGVyZmFjZSBFZGdlIHtcbiAgaWQ6IHN0cmluZztcbiAgc291cmNlOiBzdHJpbmc7XG4gIHRhcmdldDogc3RyaW5nO1xuICBzb3VyY2VIYW5kbGU/OiBzdHJpbmc7XG4gIHRhcmdldEhhbmRsZT86IHN0cmluZztcbiAgYW5pbWF0ZWQ/OiBib29sZWFuO1xuICBzdHlsZT86IGFueTtcbiAgbGFiZWw/OiBzdHJpbmc7XG4gIGRhdGE/OiB7XG4gICAgY29uZGl0aW9uPzogRWRnZUNvbmRpdGlvbjtcbiAgICBjdXN0b21Db25kaXRpb24/OiBzdHJpbmc7XG4gICAgYnJhbmNoPzogc3RyaW5nO1xuICAgIHByaW9yaXR5PzogbnVtYmVyO1xuICAgIHBhcmFsbGVsQnJhbmNoPzogYm9vbGVhbjtcbiAgICBpc1JldHJ5RWRnZT86IGJvb2xlYW47XG4gIH07XG4gIHNlbGVjdGVkPzogYm9vbGVhbjtcbn1cblxuLy8gRXJyb3IgbWVzc2FnZXMgZm9yIHZhbGlkYXRpb25cbmNvbnN0IEVSUk9SX01FU1NBR0VTID0ge1xuICBTVEFSVF9OT0RFX0VYSVNUUzogJ0EgZ3JhcGggY2FuIG9ubHkgaGF2ZSBvbmUgU1RBUlQgbm9kZScsXG4gIElOVkFMSURfQ09OTkVDVElPTjogJ1RoaXMgY29ubmVjdGlvbiBpcyBub3QgYWxsb3dlZCcsXG4gIFNUQVJUX1JFUVVJUkVEOiAnQSBncmFwaCBtdXN0IGhhdmUgYSBTVEFSVCBub2RlJyxcbiAgRURHRV9GUk9NX0VORDogJ0VORCBub2RlcyBjYW5ub3QgaGF2ZSBvdXRnb2luZyBlZGdlcycsXG4gIERVUExJQ0FURV9FREdFOiAnVGhpcyBjb25uZWN0aW9uIGFscmVhZHkgZXhpc3RzJyxcbiAgU0VMRl9DT05ORUNUSU9OOiAnQSBub2RlIGNhbm5vdCBjb25uZWN0IHRvIGl0c2VsZicsXG4gIFBBUkFMTEVMX0ZPUktfTUlOX0VER0VTOiAnUGFyYWxsZWwgRm9yayBub2RlcyBtdXN0IGhhdmUgYXQgbGVhc3QgMiBvdXRnb2luZyBlZGdlcycsXG4gIFBBUkFMTEVMX0pPSU5fTUlOX0VER0VTOiAnUGFyYWxsZWwgSm9pbiBub2RlcyBtdXN0IGhhdmUgYXQgbGVhc3QgMiBpbmNvbWluZyBlZGdlcycsXG4gIExPT1BfQ1lDTEVfUkVRVUlSRUQ6ICdMb29wIG5vZGVzIG11c3QgaGF2ZSBhIGN5Y2xlJyxcbn07XG5cbmludGVyZmFjZSBHcmFwaFN0YXRlIHtcbiAgLy8gR3JhcGggZGF0YVxuICBub2RlczogTm9kZVtdO1xuICBlZGdlczogRWRnZVtdO1xuICBzZWxlY3RlZE5vZGVJZDogc3RyaW5nIHwgbnVsbDtcbiAgc2VsZWN0ZWRFZGdlSWQ6IHN0cmluZyB8IG51bGw7XG4gIGdyYXBoTmFtZTogc3RyaW5nO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDsgLy8gRm9yIHN0b3JpbmcgdmFsaWRhdGlvbiBlcnJvcnNcbiAgaXNWYWxpZDogYm9vbGVhbjsgLy8gRmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBncmFwaCBpcyB2YWxpZFxuICBcbiAgLy8gQWN0aW9uc1xuICBzZXROb2RlczogKG5vZGVzOiBOb2RlW10pID0+IHZvaWQ7XG4gIHNldEVkZ2VzOiAoZWRnZXM6IEVkZ2VbXSkgPT4gdm9pZDtcbiAgYWRkTm9kZTogKG5vZGU6IE5vZGUpID0+IHZvaWQ7XG4gIHVwZGF0ZU5vZGU6IChpZDogc3RyaW5nLCBkYXRhOiBQYXJ0aWFsPE5vZGU+KSA9PiB2b2lkO1xuICByZW1vdmVOb2RlOiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgY2FuQWRkRWRnZTogKHNvdXJjZTogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZykgPT4geyB2YWxpZDogYm9vbGVhbjsgbWVzc2FnZT86IHN0cmluZyB9O1xuICBhZGRFZGdlOiAoZWRnZTogRWRnZSkgPT4gdm9pZDtcbiAgdXBkYXRlRWRnZTogKGlkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8RWRnZT4pID0+IHZvaWQ7XG4gIHJlbW92ZUVkZ2U6IChpZDogc3RyaW5nKSA9PiB2b2lkO1xuICBzZXRTZWxlY3RlZE5vZGVJZDogKGlkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRTZWxlY3RlZEVkZ2VJZDogKGlkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRHcmFwaE5hbWU6IChuYW1lOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGNsZWFyR3JhcGg6ICgpID0+IHZvaWQ7XG4gIHZhbGlkYXRlR3JhcGg6ICgpID0+IHsgdmFsaWQ6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmcgfTtcbiAgc2V0RXJyb3I6IChlcnJvcjogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbiAgXG4gIC8vIE5vZGUgdHlwZSBzcGVjaWZpYyBhY3Rpb25zXG4gIGFkZERlY2lzaW9uQnJhbmNoOiAobm9kZUlkOiBzdHJpbmcsIGJyYW5jaE5hbWU6IHN0cmluZykgPT4gdm9pZDtcbiAgcmVtb3ZlRGVjaXNpb25CcmFuY2g6IChub2RlSWQ6IHN0cmluZywgYnJhbmNoSW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbiAgYWRkTG9vcEN5Y2xlOiAobG9vcE5vZGVJZDogc3RyaW5nLCB0YXJnZXROb2RlSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgc2V0Tm9kZVBhcmVudDogKG5vZGVJZDogc3RyaW5nLCBwYXJlbnRJZDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbn1cblxuLy8gQ3JlYXRlIHRoZSBzdG9yZVxuZXhwb3J0IGNvbnN0IHVzZUdyYXBoU3RvcmUgPSBjcmVhdGU8R3JhcGhTdGF0ZT4oKShcbiAgcGVyc2lzdChcbiAgICAoc2V0LCBnZXQpID0+ICh7XG4gICAgICAvLyBJbml0aWFsIHN0YXRlXG4gICAgICBub2RlczogW10sXG4gICAgICBlZGdlczogW10sXG4gICAgICBzZWxlY3RlZE5vZGVJZDogbnVsbCxcbiAgICAgIHNlbGVjdGVkRWRnZUlkOiBudWxsLFxuICAgICAgZ3JhcGhOYW1lOiAnVW50aXRsZWQgR3JhcGgnLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgXG4gICAgICAvLyBBY3Rpb25zXG4gICAgICBzZXROb2RlczogKG5vZGVzKSA9PiBzZXQoeyBub2RlcyB9KSxcbiAgICAgIHNldEVkZ2VzOiAoZWRnZXMpID0+IHNldCh7IGVkZ2VzIH0pLFxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSBhbmQgYWRkIGEgbmV3IG5vZGVcbiAgICAgIGFkZE5vZGU6IChub2RlKSA9PiB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFkZGluZyBhIFNUQVJUIG5vZGUgd2hlbiBvbmUgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gTm9kZVR5cGUuU1RBUlQgJiYgXG4gICAgICAgICAgICBnZXQoKS5ub2Rlcy5zb21lKG4gPT4gbi50eXBlID09PSBOb2RlVHlwZS5TVEFSVCkpIHtcbiAgICAgICAgICBzZXQoeyBlcnJvcjogRVJST1JfTUVTU0FHRVMuU1RBUlRfTk9ERV9FWElTVFMgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzZXQoKHN0YXRlKSA9PiAoeyBcbiAgICAgICAgICBub2RlczogWy4uLnN0YXRlLm5vZGVzLCBub2RlXSxcbiAgICAgICAgICBlcnJvcjogbnVsbCwgLy8gQ2xlYXIgYW55IHByZXZpb3VzIGVycm9yc1xuICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXZhbGlkYXRlIHRoZSBncmFwaCBhZnRlciBhZGRpbmcgYSBub2RlXG4gICAgICAgIGNvbnN0IHsgdmFsaWQsIG1lc3NhZ2UgfSA9IGdldCgpLnZhbGlkYXRlR3JhcGgoKTtcbiAgICAgICAgc2V0KHsgaXNWYWxpZDogdmFsaWQsIGVycm9yOiB2YWxpZCA/IG51bGwgOiBtZXNzYWdlIHx8IG51bGwgfSk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBVcGRhdGUgbm9kZSBkYXRhXG4gICAgICB1cGRhdGVOb2RlOiAoaWQsIGRhdGEpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZE5vZGVzID0gc3RhdGUubm9kZXMubWFwKChub2RlKSA9PlxuICAgICAgICAgIG5vZGUuaWQgPT09IGlkID8geyAuLi5ub2RlLCAuLi5kYXRhIH0gOiBub2RlXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXZhbGlkYXRlIHRoZSBncmFwaCBhZnRlciB1cGRhdGluZyBhIG5vZGVcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7IG5vZGVzOiB1cGRhdGVkTm9kZXMgfTtcbiAgICAgICAgY29uc3QgeyB2YWxpZCwgbWVzc2FnZSB9ID0gZ2V0KCkudmFsaWRhdGVHcmFwaCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICAgIGlzVmFsaWQ6IHZhbGlkLFxuICAgICAgICAgIGVycm9yOiB2YWxpZCA/IG51bGwgOiBtZXNzYWdlIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgYSBub2RlIGFuZCBhbGwgY29ubmVjdGVkIGVkZ2VzXG4gICAgICByZW1vdmVOb2RlOiAoaWQpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgbm9kZXM6IHN0YXRlLm5vZGVzLmZpbHRlcigobm9kZSkgPT4gbm9kZS5pZCAhPT0gaWQpLFxuICAgICAgICAgIGVkZ2VzOiBzdGF0ZS5lZGdlcy5maWx0ZXIoXG4gICAgICAgICAgICAoZWRnZSkgPT4gZWRnZS5zb3VyY2UgIT09IGlkICYmIGVkZ2UudGFyZ2V0ICE9PSBpZFxuICAgICAgICAgICksXG4gICAgICAgICAgLy8gQ2xlYXIgc2VsZWN0aW9uIGlmIHRoZSByZW1vdmVkIG5vZGUgd2FzIHNlbGVjdGVkXG4gICAgICAgICAgc2VsZWN0ZWROb2RlSWQ6IHN0YXRlLnNlbGVjdGVkTm9kZUlkID09PSBpZCA/IG51bGwgOiBzdGF0ZS5zZWxlY3RlZE5vZGVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJldmFsaWRhdGUgdGhlIGdyYXBoIGFmdGVyIHJlbW92aW5nIGEgbm9kZVxuICAgICAgICBjb25zdCB7IHZhbGlkLCBtZXNzYWdlIH0gPSBnZXQoKS52YWxpZGF0ZUdyYXBoKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgICAgaXNWYWxpZDogdmFsaWQsXG4gICAgICAgICAgZXJyb3I6IHZhbGlkID8gbnVsbCA6IG1lc3NhZ2UgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIGVkZ2UgYmVmb3JlIGFkZGluZ1xuICAgICAgY2FuQWRkRWRnZTogKHNvdXJjZSwgdGFyZ2V0KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzdGF0ZS5ub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gc291cmNlKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHN0YXRlLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSB0YXJnZXQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFzb3VyY2VOb2RlIHx8ICF0YXJnZXROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiAnU291cmNlIG9yIHRhcmdldCBub2RlIG5vdCBmb3VuZCcgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU2VsZi1jb25uZWN0aW9ucyBhcmUgbm90IGFsbG93ZWRcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5TRUxGX0NPTk5FQ1RJT04gfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRU5EIG5vZGVzIGNhbm5vdCBoYXZlIG91dGdvaW5nIGVkZ2VzXG4gICAgICAgIGlmIChzb3VyY2VOb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVORCkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuRURHRV9GUk9NX0VORCB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGVkZ2UgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKHN0YXRlLmVkZ2VzLnNvbWUoZSA9PiBlLnNvdXJjZSA9PT0gc291cmNlICYmIGUudGFyZ2V0ID09PSB0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5EVVBMSUNBVEVfRURHRSB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayB0eXBlLXNwZWNpZmljIGNvbm5lY3Rpb24gcnVsZXNcbiAgICAgICAgaWYgKCF2YWxpZGF0ZUVkZ2VDb25uZWN0aW9uKHNvdXJjZU5vZGUudHlwZSwgdGFyZ2V0Tm9kZS50eXBlKSkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuSU5WQUxJRF9DT05ORUNUSU9OIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBBZGQgZWRnZSB3aXRoIHZhbGlkYXRpb25cbiAgICAgIGFkZEVkZ2U6IChlZGdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdmFsaWQsIG1lc3NhZ2UgfSA9IGdldCgpLmNhbkFkZEVkZ2UoZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICBzZXQoeyBlcnJvcjogbWVzc2FnZSB8fCBFUlJPUl9NRVNTQUdFUy5JTlZBTElEX0NPTk5FQ1RJT04gfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgIGVkZ2VzOiBbLi4uc3RhdGUuZWRnZXMsIGVkZ2VdLFxuICAgICAgICAgIGVycm9yOiBudWxsLCAvLyBDbGVhciBhbnkgcHJldmlvdXMgZXJyb3JzXG4gICAgICAgIH0pKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJldmFsaWRhdGUgdGhlIGdyYXBoIGFmdGVyIGFkZGluZyBhbiBlZGdlXG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBnZXQoKS52YWxpZGF0ZUdyYXBoKCk7XG4gICAgICAgIHNldCh7IFxuICAgICAgICAgIGlzVmFsaWQ6IHZhbGlkYXRpb25SZXN1bHQudmFsaWQsIFxuICAgICAgICAgIGVycm9yOiB2YWxpZGF0aW9uUmVzdWx0LnZhbGlkID8gbnVsbCA6IHZhbGlkYXRpb25SZXN1bHQubWVzc2FnZSB8fCBudWxsIFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBlZGdlIGRhdGFcbiAgICAgIHVwZGF0ZUVkZ2U6IChpZCwgZGF0YSkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRWRnZXMgPSBzdGF0ZS5lZGdlcy5tYXAoKGVkZ2UpID0+XG4gICAgICAgICAgZWRnZS5pZCA9PT0gaWQgPyB7IC4uLmVkZ2UsIC4uLmRhdGEgfSA6IGVkZ2VcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IGVkZ2VzOiB1cGRhdGVkRWRnZXMgfTtcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgYW4gZWRnZVxuICAgICAgcmVtb3ZlRWRnZTogKGlkKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgICAgIGVkZ2VzOiBzdGF0ZS5lZGdlcy5maWx0ZXIoKGVkZ2UpID0+IGVkZ2UuaWQgIT09IGlkKSxcbiAgICAgICAgICAvLyBDbGVhciBzZWxlY3Rpb24gaWYgdGhlIHJlbW92ZWQgZWRnZSB3YXMgc2VsZWN0ZWRcbiAgICAgICAgICBzZWxlY3RlZEVkZ2VJZDogc3RhdGUuc2VsZWN0ZWRFZGdlSWQgPT09IGlkID8gbnVsbCA6IHN0YXRlLnNlbGVjdGVkRWRnZUlkLFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gUmV2YWxpZGF0ZSB0aGUgZ3JhcGggYWZ0ZXIgcmVtb3ZpbmcgYW4gZWRnZVxuICAgICAgICBjb25zdCB7IHZhbGlkLCBtZXNzYWdlIH0gPSBnZXQoKS52YWxpZGF0ZUdyYXBoKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgICAgaXNWYWxpZDogdmFsaWQsXG4gICAgICAgICAgZXJyb3I6IHZhbGlkID8gbnVsbCA6IG1lc3NhZ2UgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFNldCBzZWxlY3RlZCBub2RlIElEXG4gICAgICBzZXRTZWxlY3RlZE5vZGVJZDogKGlkKSA9PiBzZXQoe1xuICAgICAgICBzZWxlY3RlZE5vZGVJZDogaWQsXG4gICAgICAgIC8vIERlc2VsZWN0IGVkZ2Ugd2hlbiBzZWxlY3RpbmcgYSBub2RlXG4gICAgICAgIHNlbGVjdGVkRWRnZUlkOiBudWxsLFxuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFNldCBzZWxlY3RlZCBlZGdlIElEXG4gICAgICBzZXRTZWxlY3RlZEVkZ2VJZDogKGlkKSA9PiBzZXQoe1xuICAgICAgICBzZWxlY3RlZEVkZ2VJZDogaWQsXG4gICAgICAgIC8vIERlc2VsZWN0IG5vZGUgd2hlbiBzZWxlY3RpbmcgYW4gZWRnZVxuICAgICAgICBzZWxlY3RlZE5vZGVJZDogbnVsbCxcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBTZXQgZ3JhcGggbmFtZVxuICAgICAgc2V0R3JhcGhOYW1lOiAoZ3JhcGhOYW1lKSA9PiBzZXQoeyBncmFwaE5hbWUgfSksXG4gICAgICBcbiAgICAgIC8vIENsZWFyIHRoZSBlbnRpcmUgZ3JhcGhcbiAgICAgIGNsZWFyR3JhcGg6ICgpID0+IHNldCh7XG4gICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgZWRnZXM6IFtdLFxuICAgICAgICBzZWxlY3RlZE5vZGVJZDogbnVsbCxcbiAgICAgICAgc2VsZWN0ZWRFZGdlSWQ6IG51bGwsXG4gICAgICAgIGdyYXBoTmFtZTogJ1VudGl0bGVkIEdyYXBoJyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgdGhlIGVudGlyZSBncmFwaFxuICAgICAgdmFsaWRhdGVHcmFwaDogKCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBleGFjdGx5IG9uZSBTVEFSVCBub2RlXG4gICAgICAgIGNvbnN0IHN0YXJ0Tm9kZXMgPSBzdGF0ZS5ub2Rlcy5maWx0ZXIobiA9PiBuLnR5cGUgPT09IE5vZGVUeXBlLlNUQVJUKTtcbiAgICAgICAgaWYgKHN0YXJ0Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5TVEFSVF9SRVFVSVJFRCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLlNUQVJUX05PREVfRVhJU1RTIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYXRlIG5vIG91dGdvaW5nIGVkZ2VzIGZyb20gRU5EIG5vZGVzXG4gICAgICAgIGNvbnN0IGVuZE5vZGVJZHMgPSBzdGF0ZS5ub2Rlc1xuICAgICAgICAgIC5maWx0ZXIobiA9PiBuLnR5cGUgPT09IE5vZGVUeXBlLkVORClcbiAgICAgICAgICAubWFwKG4gPT4gbi5pZCk7XG4gICAgICAgICAgXG4gICAgICAgIGNvbnN0IGVuZE5vZGVPdXRnb2luZ0VkZ2VzID0gc3RhdGUuZWRnZXMuZmlsdGVyKGUgPT4gZW5kTm9kZUlkcy5pbmNsdWRlcyhlLnNvdXJjZSkpO1xuICAgICAgICBpZiAoZW5kTm9kZU91dGdvaW5nRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuRURHRV9GUk9NX0VORCB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSBQYXJhbGxlbCBGb3JrIG5vZGVzIGhhdmUgYXQgbGVhc3QgMiBvdXRnb2luZyBlZGdlc1xuICAgICAgICBjb25zdCBwYXJhbGxlbEZvcmtOb2RlcyA9IHN0YXRlLm5vZGVzLmZpbHRlcihuID0+IG4udHlwZSA9PT0gTm9kZVR5cGUuUEFSQUxMRUxfRk9SSyk7XG4gICAgICAgIGZvciAoY29uc3QgZm9ya05vZGUgb2YgcGFyYWxsZWxGb3JrTm9kZXMpIHtcbiAgICAgICAgICBjb25zdCBvdXRnb2luZ0VkZ2VzID0gc3RhdGUuZWRnZXMuZmlsdGVyKGUgPT4gZS5zb3VyY2UgPT09IGZvcmtOb2RlLmlkKTtcbiAgICAgICAgICBpZiAob3V0Z29pbmdFZGdlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLlBBUkFMTEVMX0ZPUktfTUlOX0VER0VTIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSBQYXJhbGxlbCBKb2luIG5vZGVzIGhhdmUgYXQgbGVhc3QgMiBpbmNvbWluZyBlZGdlc1xuICAgICAgICBjb25zdCBwYXJhbGxlbEpvaW5Ob2RlcyA9IHN0YXRlLm5vZGVzLmZpbHRlcihuID0+IG4udHlwZSA9PT0gTm9kZVR5cGUuUEFSQUxMRUxfSk9JTik7XG4gICAgICAgIGZvciAoY29uc3Qgam9pbk5vZGUgb2YgcGFyYWxsZWxKb2luTm9kZXMpIHtcbiAgICAgICAgICBjb25zdCBpbmNvbWluZ0VkZ2VzID0gc3RhdGUuZWRnZXMuZmlsdGVyKGUgPT4gZS50YXJnZXQgPT09IGpvaW5Ob2RlLmlkKTtcbiAgICAgICAgICBpZiAoaW5jb21pbmdFZGdlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLlBBUkFMTEVMX0pPSU5fTUlOX0VER0VTIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSBMb29wIG5vZGVzIGhhdmUgYXQgbGVhc3Qgb25lIGN5Y2xlXG4gICAgICAgIGNvbnN0IGxvb3BOb2RlcyA9IHN0YXRlLm5vZGVzLmZpbHRlcihuID0+IG4udHlwZSA9PT0gTm9kZVR5cGUuTE9PUCk7XG4gICAgICAgIGZvciAoY29uc3QgbG9vcE5vZGUgb2YgbG9vcE5vZGVzKSB7XG4gICAgICAgICAgLy8gRmluZCBpZiB0aGVyZSdzIGEgcGF0aCBiYWNrIHRvIHRoaXMgbG9vcCBub2RlXG4gICAgICAgICAgY29uc3QgaGFzQ3ljbGUgPSBoYXNDeWNsZVRvTm9kZShsb29wTm9kZS5pZCwgc3RhdGUuZWRnZXMpO1xuICAgICAgICAgIGlmICghaGFzQ3ljbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuTE9PUF9DWUNMRV9SRVFVSVJFRCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIFNldCBlcnJvciBtZXNzYWdlXG4gICAgICBzZXRFcnJvcjogKGVycm9yKSA9PiBzZXQoeyBlcnJvciB9KSxcbiAgICAgIFxuICAgICAgLy8gQWRkIGEgbmV3IGJyYW5jaCB0byBhIGRlY2lzaW9uIG5vZGVcbiAgICAgIGFkZERlY2lzaW9uQnJhbmNoOiAobm9kZUlkLCBicmFuY2hOYW1lKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzdGF0ZS5ub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gbm9kZUlkKTtcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUudHlwZSAhPT0gTm9kZVR5cGUuREVDSVNJT04pIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbm9kZSdzIGJyYW5jaGVzIGFycmF5XG4gICAgICAgIGNvbnN0IHVwZGF0ZWROb2RlcyA9IHN0YXRlLm5vZGVzLm1hcChuID0+IHtcbiAgICAgICAgICBpZiAobi5pZCA9PT0gbm9kZUlkKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QnJhbmNoZXMgPSBuLmRhdGEuYnJhbmNoZXMgfHwgW107XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5uLFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgLi4ubi5kYXRhLFxuICAgICAgICAgICAgICAgIGJyYW5jaGVzOiBbLi4uY3VycmVudEJyYW5jaGVzLCBicmFuY2hOYW1lXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBub2RlczogdXBkYXRlZE5vZGVzIH07XG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGEgYnJhbmNoIGZyb20gYSBkZWNpc2lvbiBub2RlXG4gICAgICByZW1vdmVEZWNpc2lvbkJyYW5jaDogKG5vZGVJZCwgYnJhbmNoSW5kZXgpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXRlLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSBub2RlSWQpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS50eXBlICE9PSBOb2RlVHlwZS5ERUNJU0lPTikgcmV0dXJuIHN0YXRlO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBub2RlJ3MgYnJhbmNoZXMgYXJyYXlcbiAgICAgICAgY29uc3QgdXBkYXRlZE5vZGVzID0gc3RhdGUubm9kZXMubWFwKG4gPT4ge1xuICAgICAgICAgIGlmIChuLmlkID09PSBub2RlSWQgJiYgbi5kYXRhLmJyYW5jaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBicmFuY2hlcyA9IFsuLi5uLmRhdGEuYnJhbmNoZXNdO1xuICAgICAgICAgICAgYnJhbmNoZXMuc3BsaWNlKGJyYW5jaEluZGV4LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLm4sXG4gICAgICAgICAgICAgIGRhdGE6IHsgLi4ubi5kYXRhLCBicmFuY2hlcyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBub2RlczogdXBkYXRlZE5vZGVzIH07XG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gQWRkIGEgY3ljbGUgY29ubmVjdGlvbiBmb3IgYSBsb29wIG5vZGVcbiAgICAgIGFkZExvb3BDeWNsZTogKGxvb3BOb2RlSWQsIHRhcmdldE5vZGVJZCkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZWRnZSBmcm9tIHRhcmdldCB0byBsb29wIG5vZGUgdG8gY3JlYXRlIGEgY3ljbGVcbiAgICAgICAgY29uc3QgbmV3RWRnZTogRWRnZSA9IHtcbiAgICAgICAgICBpZDogYGVkZ2UtJHtsb29wTm9kZUlkfS0ke3RhcmdldE5vZGVJZH0tY3ljbGVgLFxuICAgICAgICAgIHNvdXJjZTogdGFyZ2V0Tm9kZUlkLFxuICAgICAgICAgIHRhcmdldDogbG9vcE5vZGVJZCxcbiAgICAgICAgICBhbmltYXRlZDogdHJ1ZSxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBjb25kaXRpb246IEVkZ2VDb25kaXRpb24uQUxXQVlTLFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IGVkZ2VzOiBbLi4uc3RhdGUuZWRnZXMsIG5ld0VkZ2VdIH07XG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gU2V0IGEgbm9kZSdzIHBhcmVudCAoZm9yIHN1YmdyYXBocylcbiAgICAgIHNldE5vZGVQYXJlbnQ6IChub2RlSWQsIHBhcmVudElkKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWROb2RlcyA9IHN0YXRlLm5vZGVzLm1hcChuID0+IHtcbiAgICAgICAgICBpZiAobi5pZCA9PT0gbm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5uLFxuICAgICAgICAgICAgICBwYXJlbnROb2RlOiBwYXJlbnRJZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIC8vIEluY3JlYXNlIHpJbmRleCB3aGVuIG5vZGUgaXMgbmVzdGVkXG4gICAgICAgICAgICAgIHpJbmRleDogcGFyZW50SWQgPyAxMCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IHVwZGF0ZWROb2RlcyB9O1xuICAgICAgfSksXG4gICAgfSksXG4gICAge1xuICAgICAgbmFtZTogJ2xhbmdncmFwaC1zdG9yYWdlJyxcbiAgICB9XG4gIClcbik7XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUdyYXBoU3RvcmU7XG5cbi8vIEN1c3RvbSBob29rIHRvIGFjY2VzcyBncmFwaCBkYXRhIGNvbnZlbmllbnRseVxuZXhwb3J0IGNvbnN0IHVzZUdyYXBoID0gKCkgPT4ge1xuICBjb25zdCBub2RlcyA9IHVzZUdyYXBoU3RvcmUoc3RhdGUgPT4gc3RhdGUubm9kZXMpO1xuICBjb25zdCBlZGdlcyA9IHVzZUdyYXBoU3RvcmUoc3RhdGUgPT4gc3RhdGUuZWRnZXMpO1xuICBjb25zdCBncmFwaE5hbWUgPSB1c2VHcmFwaFN0b3JlKHN0YXRlID0+IHN0YXRlLmdyYXBoTmFtZSk7XG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcywgZ3JhcGhOYW1lIH07XG59O1xuIl0sIm5hbWVzIjpbImNyZWF0ZSIsInBlcnNpc3QiLCJ2YWxpZGF0ZUVkZ2VDb25uZWN0aW9uIiwiaGFzQ3ljbGVUb05vZGUiLCJ0YXJnZXROb2RlSWQiLCJlZGdlcyIsInZpc2l0ZWQiLCJTZXQiLCJwYXRoIiwiY3VycmVudE5vZGUiLCJzb3VyY2VzVG9UYXJnZXQiLCJmaWx0ZXIiLCJlIiwidGFyZ2V0IiwibWFwIiwic291cmNlIiwiaGFzIiwiYWRkIiwib3V0Z29pbmdFZGdlcyIsImVkZ2UiLCJkZWxldGUiLCJOb2RlVHlwZSIsIkVkZ2VDb25kaXRpb24iLCJFUlJPUl9NRVNTQUdFUyIsIlNUQVJUX05PREVfRVhJU1RTIiwiSU5WQUxJRF9DT05ORUNUSU9OIiwiU1RBUlRfUkVRVUlSRUQiLCJFREdFX0ZST01fRU5EIiwiRFVQTElDQVRFX0VER0UiLCJTRUxGX0NPTk5FQ1RJT04iLCJQQVJBTExFTF9GT1JLX01JTl9FREdFUyIsIlBBUkFMTEVMX0pPSU5fTUlOX0VER0VTIiwiTE9PUF9DWUNMRV9SRVFVSVJFRCIsInVzZUdyYXBoU3RvcmUiLCJzZXQiLCJnZXQiLCJub2RlcyIsInNlbGVjdGVkTm9kZUlkIiwic2VsZWN0ZWRFZGdlSWQiLCJncmFwaE5hbWUiLCJlcnJvciIsImlzVmFsaWQiLCJzZXROb2RlcyIsInNldEVkZ2VzIiwiYWRkTm9kZSIsIm5vZGUiLCJ0eXBlIiwic29tZSIsIm4iLCJzdGF0ZSIsInZhbGlkIiwibWVzc2FnZSIsInZhbGlkYXRlR3JhcGgiLCJ1cGRhdGVOb2RlIiwiaWQiLCJkYXRhIiwidXBkYXRlZE5vZGVzIiwibmV3U3RhdGUiLCJyZW1vdmVOb2RlIiwiY2FuQWRkRWRnZSIsInNvdXJjZU5vZGUiLCJmaW5kIiwidGFyZ2V0Tm9kZSIsImFkZEVkZ2UiLCJ2YWxpZGF0aW9uUmVzdWx0IiwidXBkYXRlRWRnZSIsInVwZGF0ZWRFZGdlcyIsInJlbW92ZUVkZ2UiLCJzZXRTZWxlY3RlZE5vZGVJZCIsInNldFNlbGVjdGVkRWRnZUlkIiwic2V0R3JhcGhOYW1lIiwiY2xlYXJHcmFwaCIsInN0YXJ0Tm9kZXMiLCJsZW5ndGgiLCJlbmROb2RlSWRzIiwiZW5kTm9kZU91dGdvaW5nRWRnZXMiLCJpbmNsdWRlcyIsInBhcmFsbGVsRm9ya05vZGVzIiwiZm9ya05vZGUiLCJwYXJhbGxlbEpvaW5Ob2RlcyIsImpvaW5Ob2RlIiwiaW5jb21pbmdFZGdlcyIsImxvb3BOb2RlcyIsImxvb3BOb2RlIiwiaGFzQ3ljbGUiLCJzZXRFcnJvciIsImFkZERlY2lzaW9uQnJhbmNoIiwibm9kZUlkIiwiYnJhbmNoTmFtZSIsImN1cnJlbnRCcmFuY2hlcyIsImJyYW5jaGVzIiwicmVtb3ZlRGVjaXNpb25CcmFuY2giLCJicmFuY2hJbmRleCIsInNwbGljZSIsImFkZExvb3BDeWNsZSIsImxvb3BOb2RlSWQiLCJuZXdFZGdlIiwiYW5pbWF0ZWQiLCJjb25kaXRpb24iLCJzZXROb2RlUGFyZW50IiwicGFyZW50SWQiLCJwYXJlbnROb2RlIiwidW5kZWZpbmVkIiwiekluZGV4IiwibmFtZSIsInVzZUdyYXBoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/graphStore.ts\n"));

/***/ })

});