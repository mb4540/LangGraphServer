"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/store/graphStore.ts":
/*!*********************************!*\
  !*** ./src/store/graphStore.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EdgeCondition: function() { return /* binding */ EdgeCondition; },\n/* harmony export */   NodeType: function() { return /* binding */ NodeType; },\n/* harmony export */   useGraph: function() { return /* binding */ useGraph; },\n/* harmony export */   useGraphStore: function() { return /* binding */ useGraphStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var _utils_schemaUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/schemaUtils */ \"(app-pages-browser)/./src/utils/schemaUtils.ts\");\n\n\n\n// Helper function to detect cycles in the graph\n// Used for validating Loop nodes\nfunction hasCycleToNode(targetNodeId, edges) {\n    let visited = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Set(), path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new Set(), currentNode = arguments.length > 4 ? arguments[4] : void 0;\n    // If no current node is specified, we need to check all possible starting points\n    if (!currentNode) {\n        // Get all nodes that have edges targeting our loop node\n        const sourcesToTarget = edges.filter((e)=>e.target === targetNodeId).map((e)=>e.source);\n        // For each potential starting point, check if there's a path back to the target\n        for (const source of sourcesToTarget){\n            if (hasCycleToNode(targetNodeId, edges, new Set(), new Set(), source)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // If we've already visited this node in the current path, we found a cycle\n    if (path.has(currentNode)) {\n        return true;\n    }\n    // If we've already visited this node in another path, no need to check again\n    if (visited.has(currentNode)) {\n        return false;\n    }\n    // Mark the current node as visited and add it to the current path\n    visited.add(currentNode);\n    path.add(currentNode);\n    // Check all outgoing edges from the current node\n    const outgoingEdges = edges.filter((e)=>e.source === currentNode);\n    for (const edge of outgoingEdges){\n        // If we find a direct edge back to our target, we found a cycle\n        if (edge.target === targetNodeId) {\n            return true;\n        }\n        // Otherwise, continue searching from the target of this edge\n        if (hasCycleToNode(targetNodeId, edges, visited, path, edge.target)) {\n            return true;\n        }\n    }\n    // Remove the current node from the path as we backtrack\n    path.delete(currentNode);\n    return false;\n}\nvar NodeType;\n(function(NodeType) {\n    NodeType[\"START\"] = \"startNode\";\n    NodeType[\"END\"] = \"endNode\";\n    NodeType[\"AGENT\"] = \"agentNode\";\n    NodeType[\"TOOL\"] = \"toolNode\";\n    NodeType[\"MEMORY_READ\"] = \"memoryReadNode\";\n    NodeType[\"MEMORY_WRITE\"] = \"memoryWriteNode\";\n    NodeType[\"DECISION\"] = \"decisionNode\";\n    NodeType[\"PARALLEL_FORK\"] = \"parallelForkNode\";\n    NodeType[\"PARALLEL_JOIN\"] = \"parallelJoinNode\";\n    NodeType[\"LOOP\"] = \"loopNode\";\n    NodeType[\"ERROR_RETRY\"] = \"errorRetryNode\";\n    NodeType[\"TIMEOUT_GUARD\"] = \"timeoutGuardNode\";\n    NodeType[\"HUMAN_PAUSE\"] = \"humanPauseNode\";\n    NodeType[\"SUBGRAPH\"] = \"subgraphNode\";\n    NodeType[\"CUSTOM\"] = \"customNode\";\n})(NodeType || (NodeType = {}));\nvar EdgeCondition;\n(function(EdgeCondition) {\n    EdgeCondition[\"ALWAYS\"] = \"always\";\n    EdgeCondition[\"SUCCESS\"] = \"success\";\n    EdgeCondition[\"FAILURE\"] = \"failure\";\n    EdgeCondition[\"CUSTOM\"] = \"custom\";\n})(EdgeCondition || (EdgeCondition = {}));\n// Error messages for validation\nconst ERROR_MESSAGES = {\n    START_NODE_EXISTS: \"A graph can only have one START node\",\n    INVALID_CONNECTION: \"This connection is not allowed\",\n    START_REQUIRED: \"A graph must have a START node\",\n    START_NO_INCOMING: \"START nodes cannot have incoming edges\",\n    START_ONE_OUTGOING: \"START node must have exactly one outgoing edge\",\n    END_REQUIRED: \"A graph must have at least one END node\",\n    EDGE_FROM_END: \"END nodes cannot have outgoing edges\",\n    DUPLICATE_EDGE: \"This connection already exists\",\n    SELF_CONNECTION: \"A node cannot connect to itself\",\n    PARALLEL_FORK_MIN_EDGES: \"Parallel Fork nodes must have at least 2 outgoing edges\",\n    PARALLEL_JOIN_MIN_EDGES: \"Parallel Join nodes must have at least 2 incoming edges\",\n    LOOP_CYCLE_REQUIRED: \"Loop nodes must have a cycle\"\n};\n// Create the store\nconst useGraphStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.persist)((set, get)=>({\n        // Initial state\n        nodes: [],\n        edges: [],\n        selectedNodeId: null,\n        selectedEdgeId: null,\n        graphName: \"Untitled Graph\",\n        error: null,\n        isValid: true,\n        // Actions\n        setNodes: (nodes)=>set({\n                nodes\n            }),\n        setEdges: (edges)=>set({\n                edges\n            }),\n        // Validate and add a new node\n        addNode: (node)=>{\n            // Check if we're adding a START node when one already exists\n            if (node.type === \"startNode\" && get().nodes.some((n)=>n.type === \"startNode\")) {\n                set({\n                    error: ERROR_MESSAGES.START_NODE_EXISTS\n                });\n                return;\n            }\n            set((state)=>({\n                    nodes: [\n                        ...state.nodes,\n                        node\n                    ],\n                    error: null\n                }));\n            // Revalidate the graph after adding a node\n            const { valid, message } = get().validateGraph();\n            set({\n                isValid: valid,\n                error: valid ? null : message || null\n            });\n        },\n        // Update node data\n        updateNode: (id, data)=>set((state)=>{\n                const updatedNodes = state.nodes.map((node)=>node.id === id ? {\n                        ...node,\n                        ...data\n                    } : node);\n                // Revalidate the graph after updating a node\n                const newState = {\n                    nodes: updatedNodes\n                };\n                const { valid, message } = get().validateGraph();\n                return {\n                    ...newState,\n                    isValid: valid,\n                    error: valid ? null : message || null\n                };\n            }),\n        // Remove a node and all connected edges\n        removeNode: (id)=>set((state)=>{\n                const newState = {\n                    nodes: state.nodes.filter((node)=>node.id !== id),\n                    edges: state.edges.filter((edge)=>edge.source !== id && edge.target !== id),\n                    // Clear selection if the removed node was selected\n                    selectedNodeId: state.selectedNodeId === id ? null : state.selectedNodeId\n                };\n                // Revalidate the graph after removing a node\n                const { valid, message } = get().validateGraph();\n                return {\n                    ...newState,\n                    isValid: valid,\n                    error: valid ? null : message || null\n                };\n            }),\n        // Validate edge before adding\n        canAddEdge: (source, target)=>{\n            const state = get();\n            const sourceNode = state.nodes.find((n)=>n.id === source);\n            const targetNode = state.nodes.find((n)=>n.id === target);\n            if (!sourceNode || !targetNode) {\n                return {\n                    valid: false,\n                    message: \"Source or target node not found\"\n                };\n            }\n            // Self-connections are not allowed\n            if (source === target) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.SELF_CONNECTION\n                };\n            }\n            // END nodes cannot have outgoing edges\n            if (sourceNode.type === \"endNode\") {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.EDGE_FROM_END\n                };\n            }\n            // Check if this edge already exists\n            if (state.edges.some((e)=>e.source === source && e.target === target)) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.DUPLICATE_EDGE\n                };\n            }\n            // Check type-specific connection rules\n            if (!(0,_utils_schemaUtils__WEBPACK_IMPORTED_MODULE_0__.validateEdgeConnection)(sourceNode.type, targetNode.type)) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.INVALID_CONNECTION\n                };\n            }\n            return {\n                valid: true\n            };\n        },\n        // Add edge with validation\n        addEdge: (edge)=>{\n            const { valid, message } = get().canAddEdge(edge.source, edge.target);\n            if (!valid) {\n                set({\n                    error: message || ERROR_MESSAGES.INVALID_CONNECTION\n                });\n                return;\n            }\n            set((state)=>({\n                    edges: [\n                        ...state.edges,\n                        edge\n                    ],\n                    error: null\n                }));\n            // Revalidate the graph after adding an edge\n            const validationResult = get().validateGraph();\n            set({\n                isValid: validationResult.valid,\n                error: validationResult.valid ? null : validationResult.message || null\n            });\n        },\n        // Update edge data\n        updateEdge: (id, data)=>set((state)=>{\n                const updatedEdges = state.edges.map((edge)=>edge.id === id ? {\n                        ...edge,\n                        ...data\n                    } : edge);\n                return {\n                    edges: updatedEdges\n                };\n            }),\n        // Remove an edge\n        removeEdge: (id)=>set((state)=>{\n                const newState = {\n                    edges: state.edges.filter((edge)=>edge.id !== id),\n                    // Clear selection if the removed edge was selected\n                    selectedEdgeId: state.selectedEdgeId === id ? null : state.selectedEdgeId\n                };\n                // Revalidate the graph after removing an edge\n                const { valid, message } = get().validateGraph();\n                return {\n                    ...newState,\n                    isValid: valid,\n                    error: valid ? null : message || null\n                };\n            }),\n        // Set selected node ID\n        setSelectedNodeId: (id)=>set({\n                selectedNodeId: id,\n                // Deselect edge when selecting a node\n                selectedEdgeId: null\n            }),\n        // Set selected edge ID\n        setSelectedEdgeId: (id)=>set({\n                selectedEdgeId: id,\n                // Deselect node when selecting an edge\n                selectedNodeId: null\n            }),\n        // Set graph name\n        setGraphName: (graphName)=>set({\n                graphName\n            }),\n        // Clear the entire graph\n        clearGraph: ()=>set({\n                nodes: [],\n                edges: [],\n                selectedNodeId: null,\n                selectedEdgeId: null,\n                graphName: \"Untitled Graph\",\n                error: null,\n                isValid: true\n            }),\n        // Validate the entire graph\n        validateGraph: ()=>{\n            const state = get();\n            // Check if there's exactly one START node\n            const startNodes = state.nodes.filter((n)=>n.type === \"startNode\");\n            if (startNodes.length === 0) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_REQUIRED\n                };\n            }\n            if (startNodes.length > 1) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_NODE_EXISTS\n                };\n            }\n            // Validate START node has exactly one outgoing edge and no incoming edges\n            const startNodeId = startNodes[0].id;\n            const startNodeOutgoingEdges = state.edges.filter((e)=>e.source === startNodeId);\n            const startNodeIncomingEdges = state.edges.filter((e)=>e.target === startNodeId);\n            if (startNodeOutgoingEdges.length !== 1) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_ONE_OUTGOING\n                };\n            }\n            if (startNodeIncomingEdges.length > 0) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.START_NO_INCOMING\n                };\n            }\n            // Validate no outgoing edges from END nodes\n            const endNodeIds = state.nodes.filter((n)=>n.type === \"endNode\").map((n)=>n.id);\n            const endNodeOutgoingEdges = state.edges.filter((e)=>endNodeIds.includes(e.source));\n            if (endNodeOutgoingEdges.length > 0) {\n                return {\n                    valid: false,\n                    message: ERROR_MESSAGES.EDGE_FROM_END\n                };\n            }\n            // Validate Parallel Fork nodes have at least 2 outgoing edges\n            const parallelForkNodes = state.nodes.filter((n)=>n.type === \"parallelForkNode\");\n            for (const forkNode of parallelForkNodes){\n                const outgoingEdges = state.edges.filter((e)=>e.source === forkNode.id);\n                if (outgoingEdges.length < 2) {\n                    return {\n                        valid: false,\n                        message: ERROR_MESSAGES.PARALLEL_FORK_MIN_EDGES\n                    };\n                }\n            }\n            // Validate Parallel Join nodes have at least 2 incoming edges\n            const parallelJoinNodes = state.nodes.filter((n)=>n.type === \"parallelJoinNode\");\n            for (const joinNode of parallelJoinNodes){\n                const incomingEdges = state.edges.filter((e)=>e.target === joinNode.id);\n                if (incomingEdges.length < 2) {\n                    return {\n                        valid: false,\n                        message: ERROR_MESSAGES.PARALLEL_JOIN_MIN_EDGES\n                    };\n                }\n            }\n            // Validate Loop nodes have at least one cycle\n            const loopNodes = state.nodes.filter((n)=>n.type === \"loopNode\");\n            for (const loopNode of loopNodes){\n                // Find if there's a path back to this loop node\n                const hasCycle = hasCycleToNode(loopNode.id, state.edges);\n                if (!hasCycle) {\n                    return {\n                        valid: false,\n                        message: ERROR_MESSAGES.LOOP_CYCLE_REQUIRED\n                    };\n                }\n            }\n            return {\n                valid: true\n            };\n        },\n        // Set error message\n        setError: (error)=>set({\n                error\n            }),\n        // Add a new branch to a decision node\n        addDecisionBranch: (nodeId, branchName)=>set((state)=>{\n                const node = state.nodes.find((n)=>n.id === nodeId);\n                if (!node || node.type !== \"decisionNode\") return state;\n                // Update the node's branches array\n                const updatedNodes = state.nodes.map((n)=>{\n                    if (n.id === nodeId) {\n                        const currentBranches = n.data.branches || [];\n                        return {\n                            ...n,\n                            data: {\n                                ...n.data,\n                                branches: [\n                                    ...currentBranches,\n                                    branchName\n                                ]\n                            }\n                        };\n                    }\n                    return n;\n                });\n                return {\n                    nodes: updatedNodes\n                };\n            }),\n        // Remove a branch from a decision node\n        removeDecisionBranch: (nodeId, branchIndex)=>set((state)=>{\n                const node = state.nodes.find((n)=>n.id === nodeId);\n                if (!node || node.type !== \"decisionNode\") return state;\n                // Update the node's branches array\n                const updatedNodes = state.nodes.map((n)=>{\n                    if (n.id === nodeId && n.data.branches) {\n                        const branches = [\n                            ...n.data.branches\n                        ];\n                        branches.splice(branchIndex, 1);\n                        return {\n                            ...n,\n                            data: {\n                                ...n.data,\n                                branches\n                            }\n                        };\n                    }\n                    return n;\n                });\n                return {\n                    nodes: updatedNodes\n                };\n            }),\n        // Add a cycle connection for a loop node\n        addLoopCycle: (loopNodeId, targetNodeId)=>set((state)=>{\n                // Create a new edge from target to loop node to create a cycle\n                const newEdge = {\n                    id: \"edge-\".concat(loopNodeId, \"-\").concat(targetNodeId, \"-cycle\"),\n                    source: targetNodeId,\n                    target: loopNodeId,\n                    animated: true,\n                    data: {\n                        condition: \"always\"\n                    }\n                };\n                return {\n                    edges: [\n                        ...state.edges,\n                        newEdge\n                    ]\n                };\n            }),\n        // Set a node's parent (for subgraphs)\n        setNodeParent: (nodeId, parentId)=>set((state)=>{\n                const updatedNodes = state.nodes.map((n)=>{\n                    if (n.id === nodeId) {\n                        return {\n                            ...n,\n                            parentNode: parentId || undefined,\n                            // Increase zIndex when node is nested\n                            zIndex: parentId ? 10 : undefined\n                        };\n                    }\n                    return n;\n                });\n                return {\n                    nodes: updatedNodes\n                };\n            })\n    }), {\n    name: \"langgraph-storage\"\n}));\n/* harmony default export */ __webpack_exports__[\"default\"] = (useGraphStore);\n// Custom hook to access graph data conveniently\nconst useGraph = ()=>{\n    const nodes = useGraphStore((state)=>state.nodes);\n    const edges = useGraphStore((state)=>state.edges);\n    const graphName = useGraphStore((state)=>state.graphName);\n    return {\n        nodes,\n        edges,\n        graphName\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9ncmFwaFN0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUM7QUFDWTtBQUNnQjtBQUU3RCxnREFBZ0Q7QUFDaEQsaUNBQWlDO0FBQ2pDLFNBQVNHLGVBQWVDLFlBQW9CLEVBQUVDLEtBQWE7UUFBRUMsVUFBQUEsaUVBQXVCLElBQUlDLE9BQU9DLE9BQUFBLGlFQUFvQixJQUFJRCxPQUFPRTtJQUM1SCxpRkFBaUY7SUFDakYsSUFBSSxDQUFDQSxhQUFhO1FBQ2hCLHdEQUF3RDtRQUN4RCxNQUFNQyxrQkFBa0JMLE1BQ3JCTSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBS1QsY0FDekJVLEdBQUcsQ0FBQ0YsQ0FBQUEsSUFBS0EsRUFBRUcsTUFBTTtRQUVwQixnRkFBZ0Y7UUFDaEYsS0FBSyxNQUFNQSxVQUFVTCxnQkFBaUI7WUFDcEMsSUFBSVAsZUFBZUMsY0FBY0MsT0FBTyxJQUFJRSxPQUFPLElBQUlBLE9BQU9RLFNBQVM7Z0JBQ3JFLE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBRUEsMkVBQTJFO0lBQzNFLElBQUlQLEtBQUtRLEdBQUcsQ0FBQ1AsY0FBYztRQUN6QixPQUFPO0lBQ1Q7SUFFQSw2RUFBNkU7SUFDN0UsSUFBSUgsUUFBUVUsR0FBRyxDQUFDUCxjQUFjO1FBQzVCLE9BQU87SUFDVDtJQUVBLGtFQUFrRTtJQUNsRUgsUUFBUVcsR0FBRyxDQUFDUjtJQUNaRCxLQUFLUyxHQUFHLENBQUNSO0lBRVQsaURBQWlEO0lBQ2pELE1BQU1TLGdCQUFnQmIsTUFBTU0sTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFRyxNQUFNLEtBQUtOO0lBQ3JELEtBQUssTUFBTVUsUUFBUUQsY0FBZTtRQUNoQyxnRUFBZ0U7UUFDaEUsSUFBSUMsS0FBS04sTUFBTSxLQUFLVCxjQUFjO1lBQ2hDLE9BQU87UUFDVDtRQUVBLDZEQUE2RDtRQUM3RCxJQUFJRCxlQUFlQyxj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LE1BQU0vQyxLQUFLO0lBQ2hELE1BQU1xQyxZQUFZTixjQUFjZ0IsQ0FBQUEsUUFBU0EsTUFBTVYsU0FBUztJQUN4RCxPQUFPO1FBQUVIO1FBQU9sQztRQUFPcUM7SUFBVTtBQUNuQyxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdG9yZS9ncmFwaFN0b3JlLnRzPzRlZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgeyBwZXJzaXN0IH0gZnJvbSAnenVzdGFuZC9taWRkbGV3YXJlJztcbmltcG9ydCB7IHZhbGlkYXRlRWRnZUNvbm5lY3Rpb24gfSBmcm9tICdAL3V0aWxzL3NjaGVtYVV0aWxzJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVjdCBjeWNsZXMgaW4gdGhlIGdyYXBoXG4vLyBVc2VkIGZvciB2YWxpZGF0aW5nIExvb3Agbm9kZXNcbmZ1bmN0aW9uIGhhc0N5Y2xlVG9Ob2RlKHRhcmdldE5vZGVJZDogc3RyaW5nLCBlZGdlczogRWRnZVtdLCB2aXNpdGVkOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKSwgcGF0aDogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCksIGN1cnJlbnROb2RlPzogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIElmIG5vIGN1cnJlbnQgbm9kZSBpcyBzcGVjaWZpZWQsIHdlIG5lZWQgdG8gY2hlY2sgYWxsIHBvc3NpYmxlIHN0YXJ0aW5nIHBvaW50c1xuICBpZiAoIWN1cnJlbnROb2RlKSB7XG4gICAgLy8gR2V0IGFsbCBub2RlcyB0aGF0IGhhdmUgZWRnZXMgdGFyZ2V0aW5nIG91ciBsb29wIG5vZGVcbiAgICBjb25zdCBzb3VyY2VzVG9UYXJnZXQgPSBlZGdlc1xuICAgICAgLmZpbHRlcihlID0+IGUudGFyZ2V0ID09PSB0YXJnZXROb2RlSWQpXG4gICAgICAubWFwKGUgPT4gZS5zb3VyY2UpO1xuICAgIFxuICAgIC8vIEZvciBlYWNoIHBvdGVudGlhbCBzdGFydGluZyBwb2ludCwgY2hlY2sgaWYgdGhlcmUncyBhIHBhdGggYmFjayB0byB0aGUgdGFyZ2V0XG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlc1RvVGFyZ2V0KSB7XG4gICAgICBpZiAoaGFzQ3ljbGVUb05vZGUodGFyZ2V0Tm9kZUlkLCBlZGdlcywgbmV3IFNldCgpLCBuZXcgU2V0KCksIHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgLy8gSWYgd2UndmUgYWxyZWFkeSB2aXNpdGVkIHRoaXMgbm9kZSBpbiB0aGUgY3VycmVudCBwYXRoLCB3ZSBmb3VuZCBhIGN5Y2xlXG4gIGlmIChwYXRoLmhhcyhjdXJyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBcbiAgLy8gSWYgd2UndmUgYWxyZWFkeSB2aXNpdGVkIHRoaXMgbm9kZSBpbiBhbm90aGVyIHBhdGgsIG5vIG5lZWQgdG8gY2hlY2sgYWdhaW5cbiAgaWYgKHZpc2l0ZWQuaGFzKGN1cnJlbnROb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgLy8gTWFyayB0aGUgY3VycmVudCBub2RlIGFzIHZpc2l0ZWQgYW5kIGFkZCBpdCB0byB0aGUgY3VycmVudCBwYXRoXG4gIHZpc2l0ZWQuYWRkKGN1cnJlbnROb2RlKTtcbiAgcGF0aC5hZGQoY3VycmVudE5vZGUpO1xuICBcbiAgLy8gQ2hlY2sgYWxsIG91dGdvaW5nIGVkZ2VzIGZyb20gdGhlIGN1cnJlbnQgbm9kZVxuICBjb25zdCBvdXRnb2luZ0VkZ2VzID0gZWRnZXMuZmlsdGVyKGUgPT4gZS5zb3VyY2UgPT09IGN1cnJlbnROb2RlKTtcbiAgZm9yIChjb25zdCBlZGdlIG9mIG91dGdvaW5nRWRnZXMpIHtcbiAgICAvLyBJZiB3ZSBmaW5kIGEgZGlyZWN0IGVkZ2UgYmFjayB0byBvdXIgdGFyZ2V0LCB3ZSBmb3VuZCBhIGN5Y2xlXG4gICAgaWYgKGVkZ2UudGFyZ2V0ID09PSB0YXJnZXROb2RlSWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBPdGhlcndpc2UsIGNvbnRpbnVlIHNlYXJjaGluZyBmcm9tIHRoZSB0YXJnZXQgb2YgdGhpcyBlZGdlXG4gICAgaWYgKGhhc0N5Y2xlVG9Ob2RlKHRhcmdldE5vZGVJZCwgZWRnZXMsIHZpc2l0ZWQsIHBhdGgsIGVkZ2UudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIFxuICAvLyBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSBmcm9tIHRoZSBwYXRoIGFzIHdlIGJhY2t0cmFja1xuICBwYXRoLmRlbGV0ZShjdXJyZW50Tm9kZSk7XG4gIFxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIE5vZGUgdHlwZXMgZW51bSBmb3IgaW1wcm92ZWQgdHlwZSBzYWZldHlcbmV4cG9ydCBlbnVtIE5vZGVUeXBlIHtcbiAgU1RBUlQgPSAnc3RhcnROb2RlJyxcbiAgRU5EID0gJ2VuZE5vZGUnLFxuICBBR0VOVCA9ICdhZ2VudE5vZGUnLFxuICBUT09MID0gJ3Rvb2xOb2RlJyxcbiAgTUVNT1JZX1JFQUQgPSAnbWVtb3J5UmVhZE5vZGUnLFxuICBNRU1PUllfV1JJVEUgPSAnbWVtb3J5V3JpdGVOb2RlJyxcbiAgREVDSVNJT04gPSAnZGVjaXNpb25Ob2RlJyxcbiAgUEFSQUxMRUxfRk9SSyA9ICdwYXJhbGxlbEZvcmtOb2RlJyxcbiAgUEFSQUxMRUxfSk9JTiA9ICdwYXJhbGxlbEpvaW5Ob2RlJyxcbiAgTE9PUCA9ICdsb29wTm9kZScsXG4gIEVSUk9SX1JFVFJZID0gJ2Vycm9yUmV0cnlOb2RlJyxcbiAgVElNRU9VVF9HVUFSRCA9ICd0aW1lb3V0R3VhcmROb2RlJyxcbiAgSFVNQU5fUEFVU0UgPSAnaHVtYW5QYXVzZU5vZGUnLFxuICBTVUJHUkFQSCA9ICdzdWJncmFwaE5vZGUnLFxuICBDVVNUT00gPSAnY3VzdG9tTm9kZSdcbn1cblxuLy8gQmFzaWMgbm9kZSBpbnRlcmZhY2VcbmludGVyZmFjZSBOb2RlIHtcbiAgaWQ6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xuICBwb3NpdGlvbjogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICBkYXRhOiB7IGxhYmVsOiBzdHJpbmc7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICBzZWxlY3RlZD86IGJvb2xlYW47XG4gIHBhcmVudE5vZGU/OiBzdHJpbmc7XG4gIHpJbmRleD86IG51bWJlcjtcbn1cblxuLy8gRWRnZSBjb25kaXRpb24gdHlwZXMgZW51bSBmb3IgaW1wcm92ZWQgdHlwZSBzYWZldHlcbmV4cG9ydCBlbnVtIEVkZ2VDb25kaXRpb24ge1xuICBBTFdBWVMgPSAnYWx3YXlzJyxcbiAgU1VDQ0VTUyA9ICdzdWNjZXNzJyxcbiAgRkFJTFVSRSA9ICdmYWlsdXJlJyxcbiAgQ1VTVE9NID0gJ2N1c3RvbSdcbn1cblxuLy8gRW5oYW5jZWQgZWRnZSBpbnRlcmZhY2Ugd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbmludGVyZmFjZSBFZGdlIHtcbiAgaWQ6IHN0cmluZztcbiAgc291cmNlOiBzdHJpbmc7XG4gIHRhcmdldDogc3RyaW5nO1xuICBzb3VyY2VIYW5kbGU/OiBzdHJpbmc7XG4gIHRhcmdldEhhbmRsZT86IHN0cmluZztcbiAgYW5pbWF0ZWQ/OiBib29sZWFuO1xuICBzdHlsZT86IGFueTtcbiAgbGFiZWw/OiBzdHJpbmc7XG4gIGRhdGE/OiB7XG4gICAgY29uZGl0aW9uPzogRWRnZUNvbmRpdGlvbjtcbiAgICBjdXN0b21Db25kaXRpb24/OiBzdHJpbmc7XG4gICAgYnJhbmNoPzogc3RyaW5nO1xuICAgIHByaW9yaXR5PzogbnVtYmVyO1xuICAgIHBhcmFsbGVsQnJhbmNoPzogYm9vbGVhbjtcbiAgICBpc1JldHJ5RWRnZT86IGJvb2xlYW47XG4gIH07XG4gIHNlbGVjdGVkPzogYm9vbGVhbjtcbn1cblxuLy8gRXJyb3IgbWVzc2FnZXMgZm9yIHZhbGlkYXRpb25cbmNvbnN0IEVSUk9SX01FU1NBR0VTID0ge1xuICBTVEFSVF9OT0RFX0VYSVNUUzogJ0EgZ3JhcGggY2FuIG9ubHkgaGF2ZSBvbmUgU1RBUlQgbm9kZScsXG4gIElOVkFMSURfQ09OTkVDVElPTjogJ1RoaXMgY29ubmVjdGlvbiBpcyBub3QgYWxsb3dlZCcsXG4gIFNUQVJUX1JFUVVJUkVEOiAnQSBncmFwaCBtdXN0IGhhdmUgYSBTVEFSVCBub2RlJyxcbiAgU1RBUlRfTk9fSU5DT01JTkc6ICdTVEFSVCBub2RlcyBjYW5ub3QgaGF2ZSBpbmNvbWluZyBlZGdlcycsXG4gIFNUQVJUX09ORV9PVVRHT0lORzogJ1NUQVJUIG5vZGUgbXVzdCBoYXZlIGV4YWN0bHkgb25lIG91dGdvaW5nIGVkZ2UnLFxuICBFTkRfUkVRVUlSRUQ6ICdBIGdyYXBoIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgRU5EIG5vZGUnLFxuICBFREdFX0ZST01fRU5EOiAnRU5EIG5vZGVzIGNhbm5vdCBoYXZlIG91dGdvaW5nIGVkZ2VzJyxcbiAgRFVQTElDQVRFX0VER0U6ICdUaGlzIGNvbm5lY3Rpb24gYWxyZWFkeSBleGlzdHMnLFxuICBTRUxGX0NPTk5FQ1RJT046ICdBIG5vZGUgY2Fubm90IGNvbm5lY3QgdG8gaXRzZWxmJyxcbiAgUEFSQUxMRUxfRk9SS19NSU5fRURHRVM6ICdQYXJhbGxlbCBGb3JrIG5vZGVzIG11c3QgaGF2ZSBhdCBsZWFzdCAyIG91dGdvaW5nIGVkZ2VzJyxcbiAgUEFSQUxMRUxfSk9JTl9NSU5fRURHRVM6ICdQYXJhbGxlbCBKb2luIG5vZGVzIG11c3QgaGF2ZSBhdCBsZWFzdCAyIGluY29taW5nIGVkZ2VzJyxcbiAgTE9PUF9DWUNMRV9SRVFVSVJFRDogJ0xvb3Agbm9kZXMgbXVzdCBoYXZlIGEgY3ljbGUnLFxufTtcblxuaW50ZXJmYWNlIEdyYXBoU3RhdGUge1xuICAvLyBHcmFwaCBkYXRhXG4gIG5vZGVzOiBOb2RlW107XG4gIGVkZ2VzOiBFZGdlW107XG4gIHNlbGVjdGVkTm9kZUlkOiBzdHJpbmcgfCBudWxsO1xuICBzZWxlY3RlZEVkZ2VJZDogc3RyaW5nIHwgbnVsbDtcbiAgZ3JhcGhOYW1lOiBzdHJpbmc7XG4gIGVycm9yOiBzdHJpbmcgfCBudWxsOyAvLyBGb3Igc3RvcmluZyB2YWxpZGF0aW9uIGVycm9yc1xuICBpc1ZhbGlkOiBib29sZWFuOyAvLyBGbGFnIGluZGljYXRpbmcgaWYgdGhlIGdyYXBoIGlzIHZhbGlkXG4gIFxuICAvLyBBY3Rpb25zXG4gIHNldE5vZGVzOiAobm9kZXM6IE5vZGVbXSkgPT4gdm9pZDtcbiAgc2V0RWRnZXM6IChlZGdlczogRWRnZVtdKSA9PiB2b2lkO1xuICBhZGROb2RlOiAobm9kZTogTm9kZSkgPT4gdm9pZDtcbiAgdXBkYXRlTm9kZTogKGlkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8Tm9kZT4pID0+IHZvaWQ7XG4gIHJlbW92ZU5vZGU6IChpZDogc3RyaW5nKSA9PiB2b2lkO1xuICBjYW5BZGRFZGdlOiAoc291cmNlOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nKSA9PiB7IHZhbGlkOiBib29sZWFuOyBtZXNzYWdlPzogc3RyaW5nIH07XG4gIGFkZEVkZ2U6IChlZGdlOiBFZGdlKSA9PiB2b2lkO1xuICB1cGRhdGVFZGdlOiAoaWQ6IHN0cmluZywgZGF0YTogUGFydGlhbDxFZGdlPikgPT4gdm9pZDtcbiAgcmVtb3ZlRWRnZTogKGlkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHNldFNlbGVjdGVkTm9kZUlkOiAoaWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIHNldFNlbGVjdGVkRWRnZUlkOiAoaWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIHNldEdyYXBoTmFtZTogKG5hbWU6IHN0cmluZykgPT4gdm9pZDtcbiAgY2xlYXJHcmFwaDogKCkgPT4gdm9pZDtcbiAgdmFsaWRhdGVHcmFwaDogKCkgPT4geyB2YWxpZDogYm9vbGVhbjsgbWVzc2FnZT86IHN0cmluZyB9O1xuICBzZXRFcnJvcjogKGVycm9yOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICBcbiAgLy8gTm9kZSB0eXBlIHNwZWNpZmljIGFjdGlvbnNcbiAgYWRkRGVjaXNpb25CcmFuY2g6IChub2RlSWQ6IHN0cmluZywgYnJhbmNoTmFtZTogc3RyaW5nKSA9PiB2b2lkO1xuICByZW1vdmVEZWNpc2lvbkJyYW5jaDogKG5vZGVJZDogc3RyaW5nLCBicmFuY2hJbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuICBhZGRMb29wQ3ljbGU6IChsb29wTm9kZUlkOiBzdHJpbmcsIHRhcmdldE5vZGVJZDogc3RyaW5nKSA9PiB2b2lkO1xuICBzZXROb2RlUGFyZW50OiAobm9kZUlkOiBzdHJpbmcsIHBhcmVudElkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xufVxuXG4vLyBDcmVhdGUgdGhlIHN0b3JlXG5leHBvcnQgY29uc3QgdXNlR3JhcGhTdG9yZSA9IGNyZWF0ZTxHcmFwaFN0YXRlPigpKFxuICBwZXJzaXN0KFxuICAgIChzZXQsIGdldCkgPT4gKHtcbiAgICAgIC8vIEluaXRpYWwgc3RhdGVcbiAgICAgIG5vZGVzOiBbXSxcbiAgICAgIGVkZ2VzOiBbXSxcbiAgICAgIHNlbGVjdGVkTm9kZUlkOiBudWxsLFxuICAgICAgc2VsZWN0ZWRFZGdlSWQ6IG51bGwsXG4gICAgICBncmFwaE5hbWU6ICdVbnRpdGxlZCBHcmFwaCcsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICBcbiAgICAgIC8vIEFjdGlvbnNcbiAgICAgIHNldE5vZGVzOiAobm9kZXMpID0+IHNldCh7IG5vZGVzIH0pLFxuICAgICAgc2V0RWRnZXM6IChlZGdlcykgPT4gc2V0KHsgZWRnZXMgfSksXG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIGFuZCBhZGQgYSBuZXcgbm9kZVxuICAgICAgYWRkTm9kZTogKG5vZGUpID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgYWRkaW5nIGEgU1RBUlQgbm9kZSB3aGVuIG9uZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBOb2RlVHlwZS5TVEFSVCAmJiBcbiAgICAgICAgICAgIGdldCgpLm5vZGVzLnNvbWUobiA9PiBuLnR5cGUgPT09IE5vZGVUeXBlLlNUQVJUKSkge1xuICAgICAgICAgIHNldCh7IGVycm9yOiBFUlJPUl9NRVNTQUdFUy5TVEFSVF9OT0RFX0VYSVNUUyB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNldCgoc3RhdGUpID0+ICh7IFxuICAgICAgICAgIG5vZGVzOiBbLi4uc3RhdGUubm9kZXMsIG5vZGVdLFxuICAgICAgICAgIGVycm9yOiBudWxsLCAvLyBDbGVhciBhbnkgcHJldmlvdXMgZXJyb3JzXG4gICAgICAgIH0pKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJldmFsaWRhdGUgdGhlIGdyYXBoIGFmdGVyIGFkZGluZyBhIG5vZGVcbiAgICAgICAgY29uc3QgeyB2YWxpZCwgbWVzc2FnZSB9ID0gZ2V0KCkudmFsaWRhdGVHcmFwaCgpO1xuICAgICAgICBzZXQoeyBpc1ZhbGlkOiB2YWxpZCwgZXJyb3I6IHZhbGlkID8gbnVsbCA6IG1lc3NhZ2UgfHwgbnVsbCB9KTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBub2RlIGRhdGFcbiAgICAgIHVwZGF0ZU5vZGU6IChpZCwgZGF0YSkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkTm9kZXMgPSBzdGF0ZS5ub2Rlcy5tYXAoKG5vZGUpID0+XG4gICAgICAgICAgbm9kZS5pZCA9PT0gaWQgPyB7IC4uLm5vZGUsIC4uLmRhdGEgfSA6IG5vZGVcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJldmFsaWRhdGUgdGhlIGdyYXBoIGFmdGVyIHVwZGF0aW5nIGEgbm9kZVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHsgbm9kZXM6IHVwZGF0ZWROb2RlcyB9O1xuICAgICAgICBjb25zdCB7IHZhbGlkLCBtZXNzYWdlIH0gPSBnZXQoKS52YWxpZGF0ZUdyYXBoKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgICAgaXNWYWxpZDogdmFsaWQsXG4gICAgICAgICAgZXJyb3I6IHZhbGlkID8gbnVsbCA6IG1lc3NhZ2UgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBhIG5vZGUgYW5kIGFsbCBjb25uZWN0ZWQgZWRnZXNcbiAgICAgIHJlbW92ZU5vZGU6IChpZCkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICBub2Rlczogc3RhdGUubm9kZXMuZmlsdGVyKChub2RlKSA9PiBub2RlLmlkICE9PSBpZCksXG4gICAgICAgICAgZWRnZXM6IHN0YXRlLmVkZ2VzLmZpbHRlcihcbiAgICAgICAgICAgIChlZGdlKSA9PiBlZGdlLnNvdXJjZSAhPT0gaWQgJiYgZWRnZS50YXJnZXQgIT09IGlkXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBDbGVhciBzZWxlY3Rpb24gaWYgdGhlIHJlbW92ZWQgbm9kZSB3YXMgc2VsZWN0ZWRcbiAgICAgICAgICBzZWxlY3RlZE5vZGVJZDogc3RhdGUuc2VsZWN0ZWROb2RlSWQgPT09IGlkID8gbnVsbCA6IHN0YXRlLnNlbGVjdGVkTm9kZUlkLFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gUmV2YWxpZGF0ZSB0aGUgZ3JhcGggYWZ0ZXIgcmVtb3ZpbmcgYSBub2RlXG4gICAgICAgIGNvbnN0IHsgdmFsaWQsIG1lc3NhZ2UgfSA9IGdldCgpLnZhbGlkYXRlR3JhcGgoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgICBpc1ZhbGlkOiB2YWxpZCxcbiAgICAgICAgICBlcnJvcjogdmFsaWQgPyBudWxsIDogbWVzc2FnZSB8fCBudWxsXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgZWRnZSBiZWZvcmUgYWRkaW5nXG4gICAgICBjYW5BZGRFZGdlOiAoc291cmNlLCB0YXJnZXQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IHN0YXRlLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSBzb3VyY2UpO1xuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gc3RhdGUubm9kZXMuZmluZChuID0+IG4uaWQgPT09IHRhcmdldCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXNvdXJjZU5vZGUgfHwgIXRhcmdldE5vZGUpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6ICdTb3VyY2Ugb3IgdGFyZ2V0IG5vZGUgbm90IGZvdW5kJyB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTZWxmLWNvbm5lY3Rpb25zIGFyZSBub3QgYWxsb3dlZFxuICAgICAgICBpZiAoc291cmNlID09PSB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLlNFTEZfQ09OTkVDVElPTiB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBFTkQgbm9kZXMgY2Fubm90IGhhdmUgb3V0Z29pbmcgZWRnZXNcbiAgICAgICAgaWYgKHNvdXJjZU5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRU5EKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5FREdFX0ZST01fRU5EIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgZWRnZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBpZiAoc3RhdGUuZWRnZXMuc29tZShlID0+IGUuc291cmNlID09PSBzb3VyY2UgJiYgZS50YXJnZXQgPT09IHRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLkRVUExJQ0FURV9FREdFIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIHR5cGUtc3BlY2lmaWMgY29ubmVjdGlvbiBydWxlc1xuICAgICAgICBpZiAoIXZhbGlkYXRlRWRnZUNvbm5lY3Rpb24oc291cmNlTm9kZS50eXBlLCB0YXJnZXROb2RlLnR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5JTlZBTElEX0NPTk5FQ1RJT04gfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIEFkZCBlZGdlIHdpdGggdmFsaWRhdGlvblxuICAgICAgYWRkRWRnZTogKGVkZ2UpID0+IHtcbiAgICAgICAgY29uc3QgeyB2YWxpZCwgbWVzc2FnZSB9ID0gZ2V0KCkuY2FuQWRkRWRnZShlZGdlLnNvdXJjZSwgZWRnZS50YXJnZXQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgIHNldCh7IGVycm9yOiBtZXNzYWdlIHx8IEVSUk9SX01FU1NBR0VTLklOVkFMSURfQ09OTkVDVElPTiB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgZWRnZXM6IFsuLi5zdGF0ZS5lZGdlcywgZWRnZV0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsIC8vIENsZWFyIGFueSBwcmV2aW91cyBlcnJvcnNcbiAgICAgICAgfSkpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmV2YWxpZGF0ZSB0aGUgZ3JhcGggYWZ0ZXIgYWRkaW5nIGFuIGVkZ2VcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGdldCgpLnZhbGlkYXRlR3JhcGgoKTtcbiAgICAgICAgc2V0KHsgXG4gICAgICAgICAgaXNWYWxpZDogdmFsaWRhdGlvblJlc3VsdC52YWxpZCwgXG4gICAgICAgICAgZXJyb3I6IHZhbGlkYXRpb25SZXN1bHQudmFsaWQgPyBudWxsIDogdmFsaWRhdGlvblJlc3VsdC5tZXNzYWdlIHx8IG51bGwgXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGVkZ2UgZGF0YVxuICAgICAgdXBkYXRlRWRnZTogKGlkLCBkYXRhKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRFZGdlcyA9IHN0YXRlLmVkZ2VzLm1hcCgoZWRnZSkgPT5cbiAgICAgICAgICBlZGdlLmlkID09PSBpZCA/IHsgLi4uZWRnZSwgLi4uZGF0YSB9IDogZWRnZVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgZWRnZXM6IHVwZGF0ZWRFZGdlcyB9O1xuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBhbiBlZGdlXG4gICAgICByZW1vdmVFZGdlOiAoaWQpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgZWRnZXM6IHN0YXRlLmVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gZWRnZS5pZCAhPT0gaWQpLFxuICAgICAgICAgIC8vIENsZWFyIHNlbGVjdGlvbiBpZiB0aGUgcmVtb3ZlZCBlZGdlIHdhcyBzZWxlY3RlZFxuICAgICAgICAgIHNlbGVjdGVkRWRnZUlkOiBzdGF0ZS5zZWxlY3RlZEVkZ2VJZCA9PT0gaWQgPyBudWxsIDogc3RhdGUuc2VsZWN0ZWRFZGdlSWQsXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBSZXZhbGlkYXRlIHRoZSBncmFwaCBhZnRlciByZW1vdmluZyBhbiBlZGdlXG4gICAgICAgIGNvbnN0IHsgdmFsaWQsIG1lc3NhZ2UgfSA9IGdldCgpLnZhbGlkYXRlR3JhcGgoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgICBpc1ZhbGlkOiB2YWxpZCxcbiAgICAgICAgICBlcnJvcjogdmFsaWQgPyBudWxsIDogbWVzc2FnZSB8fCBudWxsXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gU2V0IHNlbGVjdGVkIG5vZGUgSURcbiAgICAgIHNldFNlbGVjdGVkTm9kZUlkOiAoaWQpID0+IHNldCh7XG4gICAgICAgIHNlbGVjdGVkTm9kZUlkOiBpZCxcbiAgICAgICAgLy8gRGVzZWxlY3QgZWRnZSB3aGVuIHNlbGVjdGluZyBhIG5vZGVcbiAgICAgICAgc2VsZWN0ZWRFZGdlSWQ6IG51bGwsXG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gU2V0IHNlbGVjdGVkIGVkZ2UgSURcbiAgICAgIHNldFNlbGVjdGVkRWRnZUlkOiAoaWQpID0+IHNldCh7XG4gICAgICAgIHNlbGVjdGVkRWRnZUlkOiBpZCxcbiAgICAgICAgLy8gRGVzZWxlY3Qgbm9kZSB3aGVuIHNlbGVjdGluZyBhbiBlZGdlXG4gICAgICAgIHNlbGVjdGVkTm9kZUlkOiBudWxsLFxuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFNldCBncmFwaCBuYW1lXG4gICAgICBzZXRHcmFwaE5hbWU6IChncmFwaE5hbWUpID0+IHNldCh7IGdyYXBoTmFtZSB9KSxcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgdGhlIGVudGlyZSBncmFwaFxuICAgICAgY2xlYXJHcmFwaDogKCkgPT4gc2V0KHtcbiAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICBlZGdlczogW10sXG4gICAgICAgIHNlbGVjdGVkTm9kZUlkOiBudWxsLFxuICAgICAgICBzZWxlY3RlZEVkZ2VJZDogbnVsbCxcbiAgICAgICAgZ3JhcGhOYW1lOiAnVW50aXRsZWQgR3JhcGgnLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSB0aGUgZW50aXJlIGdyYXBoXG4gICAgICB2YWxpZGF0ZUdyYXBoOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGV4YWN0bHkgb25lIFNUQVJUIG5vZGVcbiAgICAgICAgY29uc3Qgc3RhcnROb2RlcyA9IHN0YXRlLm5vZGVzLmZpbHRlcihuID0+IG4udHlwZSA9PT0gTm9kZVR5cGUuU1RBUlQpO1xuICAgICAgICBpZiAoc3RhcnROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLlNUQVJUX1JFUVVJUkVEIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0Tm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogRVJST1JfTUVTU0FHRVMuU1RBUlRfTk9ERV9FWElTVFMgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVmFsaWRhdGUgU1RBUlQgbm9kZSBoYXMgZXhhY3RseSBvbmUgb3V0Z29pbmcgZWRnZSBhbmQgbm8gaW5jb21pbmcgZWRnZXNcbiAgICAgICAgY29uc3Qgc3RhcnROb2RlSWQgPSBzdGFydE5vZGVzWzBdLmlkO1xuICAgICAgICBjb25zdCBzdGFydE5vZGVPdXRnb2luZ0VkZ2VzID0gc3RhdGUuZWRnZXMuZmlsdGVyKGUgPT4gZS5zb3VyY2UgPT09IHN0YXJ0Tm9kZUlkKTtcbiAgICAgICAgY29uc3Qgc3RhcnROb2RlSW5jb21pbmdFZGdlcyA9IHN0YXRlLmVkZ2VzLmZpbHRlcihlID0+IGUudGFyZ2V0ID09PSBzdGFydE5vZGVJZCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3RhcnROb2RlT3V0Z29pbmdFZGdlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLlNUQVJUX09ORV9PVVRHT0lORyB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoc3RhcnROb2RlSW5jb21pbmdFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5TVEFSVF9OT19JTkNPTUlORyB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSBubyBvdXRnb2luZyBlZGdlcyBmcm9tIEVORCBub2Rlc1xuICAgICAgICBjb25zdCBlbmROb2RlSWRzID0gc3RhdGUubm9kZXNcbiAgICAgICAgICAuZmlsdGVyKG4gPT4gbi50eXBlID09PSBOb2RlVHlwZS5FTkQpXG4gICAgICAgICAgLm1hcChuID0+IG4uaWQpO1xuICAgICAgICAgIFxuICAgICAgICBjb25zdCBlbmROb2RlT3V0Z29pbmdFZGdlcyA9IHN0YXRlLmVkZ2VzLmZpbHRlcihlID0+IGVuZE5vZGVJZHMuaW5jbHVkZXMoZS5zb3VyY2UpKTtcbiAgICAgICAgaWYgKGVuZE5vZGVPdXRnb2luZ0VkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLkVER0VfRlJPTV9FTkQgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVmFsaWRhdGUgUGFyYWxsZWwgRm9yayBub2RlcyBoYXZlIGF0IGxlYXN0IDIgb3V0Z29pbmcgZWRnZXNcbiAgICAgICAgY29uc3QgcGFyYWxsZWxGb3JrTm9kZXMgPSBzdGF0ZS5ub2Rlcy5maWx0ZXIobiA9PiBuLnR5cGUgPT09IE5vZGVUeXBlLlBBUkFMTEVMX0ZPUkspO1xuICAgICAgICBmb3IgKGNvbnN0IGZvcmtOb2RlIG9mIHBhcmFsbGVsRm9ya05vZGVzKSB7XG4gICAgICAgICAgY29uc3Qgb3V0Z29pbmdFZGdlcyA9IHN0YXRlLmVkZ2VzLmZpbHRlcihlID0+IGUuc291cmNlID09PSBmb3JrTm9kZS5pZCk7XG4gICAgICAgICAgaWYgKG91dGdvaW5nRWRnZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5QQVJBTExFTF9GT1JLX01JTl9FREdFUyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVmFsaWRhdGUgUGFyYWxsZWwgSm9pbiBub2RlcyBoYXZlIGF0IGxlYXN0IDIgaW5jb21pbmcgZWRnZXNcbiAgICAgICAgY29uc3QgcGFyYWxsZWxKb2luTm9kZXMgPSBzdGF0ZS5ub2Rlcy5maWx0ZXIobiA9PiBuLnR5cGUgPT09IE5vZGVUeXBlLlBBUkFMTEVMX0pPSU4pO1xuICAgICAgICBmb3IgKGNvbnN0IGpvaW5Ob2RlIG9mIHBhcmFsbGVsSm9pbk5vZGVzKSB7XG4gICAgICAgICAgY29uc3QgaW5jb21pbmdFZGdlcyA9IHN0YXRlLmVkZ2VzLmZpbHRlcihlID0+IGUudGFyZ2V0ID09PSBqb2luTm9kZS5pZCk7XG4gICAgICAgICAgaWYgKGluY29taW5nRWRnZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBFUlJPUl9NRVNTQUdFUy5QQVJBTExFTF9KT0lOX01JTl9FREdFUyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVmFsaWRhdGUgTG9vcCBub2RlcyBoYXZlIGF0IGxlYXN0IG9uZSBjeWNsZVxuICAgICAgICBjb25zdCBsb29wTm9kZXMgPSBzdGF0ZS5ub2Rlcy5maWx0ZXIobiA9PiBuLnR5cGUgPT09IE5vZGVUeXBlLkxPT1ApO1xuICAgICAgICBmb3IgKGNvbnN0IGxvb3BOb2RlIG9mIGxvb3BOb2Rlcykge1xuICAgICAgICAgIC8vIEZpbmQgaWYgdGhlcmUncyBhIHBhdGggYmFjayB0byB0aGlzIGxvb3Agbm9kZVxuICAgICAgICAgIGNvbnN0IGhhc0N5Y2xlID0gaGFzQ3ljbGVUb05vZGUobG9vcE5vZGUuaWQsIHN0YXRlLmVkZ2VzKTtcbiAgICAgICAgICBpZiAoIWhhc0N5Y2xlKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IEVSUk9SX01FU1NBR0VTLkxPT1BfQ1lDTEVfUkVRVUlSRUQgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBTZXQgZXJyb3IgbWVzc2FnZVxuICAgICAgc2V0RXJyb3I6IChlcnJvcikgPT4gc2V0KHsgZXJyb3IgfSksXG4gICAgICBcbiAgICAgIC8vIEFkZCBhIG5ldyBicmFuY2ggdG8gYSBkZWNpc2lvbiBub2RlXG4gICAgICBhZGREZWNpc2lvbkJyYW5jaDogKG5vZGVJZCwgYnJhbmNoTmFtZSkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gc3RhdGUubm9kZXMuZmluZChuID0+IG4uaWQgPT09IG5vZGVJZCk7XG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLnR5cGUgIT09IE5vZGVUeXBlLkRFQ0lTSU9OKSByZXR1cm4gc3RhdGU7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgdGhlIG5vZGUncyBicmFuY2hlcyBhcnJheVxuICAgICAgICBjb25zdCB1cGRhdGVkTm9kZXMgPSBzdGF0ZS5ub2Rlcy5tYXAobiA9PiB7XG4gICAgICAgICAgaWYgKG4uaWQgPT09IG5vZGVJZCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEJyYW5jaGVzID0gbi5kYXRhLmJyYW5jaGVzIHx8IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ubixcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIC4uLm4uZGF0YSxcbiAgICAgICAgICAgICAgICBicmFuY2hlczogWy4uLmN1cnJlbnRCcmFuY2hlcywgYnJhbmNoTmFtZV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IHVwZGF0ZWROb2RlcyB9O1xuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBhIGJyYW5jaCBmcm9tIGEgZGVjaXNpb24gbm9kZVxuICAgICAgcmVtb3ZlRGVjaXNpb25CcmFuY2g6IChub2RlSWQsIGJyYW5jaEluZGV4KSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzdGF0ZS5ub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gbm9kZUlkKTtcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUudHlwZSAhPT0gTm9kZVR5cGUuREVDSVNJT04pIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbm9kZSdzIGJyYW5jaGVzIGFycmF5XG4gICAgICAgIGNvbnN0IHVwZGF0ZWROb2RlcyA9IHN0YXRlLm5vZGVzLm1hcChuID0+IHtcbiAgICAgICAgICBpZiAobi5pZCA9PT0gbm9kZUlkICYmIG4uZGF0YS5icmFuY2hlcykge1xuICAgICAgICAgICAgY29uc3QgYnJhbmNoZXMgPSBbLi4ubi5kYXRhLmJyYW5jaGVzXTtcbiAgICAgICAgICAgIGJyYW5jaGVzLnNwbGljZShicmFuY2hJbmRleCwgMSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5uLFxuICAgICAgICAgICAgICBkYXRhOiB7IC4uLm4uZGF0YSwgYnJhbmNoZXMgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IHVwZGF0ZWROb2RlcyB9O1xuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIEFkZCBhIGN5Y2xlIGNvbm5lY3Rpb24gZm9yIGEgbG9vcCBub2RlXG4gICAgICBhZGRMb29wQ3ljbGU6IChsb29wTm9kZUlkLCB0YXJnZXROb2RlSWQpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGVkZ2UgZnJvbSB0YXJnZXQgdG8gbG9vcCBub2RlIHRvIGNyZWF0ZSBhIGN5Y2xlXG4gICAgICAgIGNvbnN0IG5ld0VkZ2U6IEVkZ2UgPSB7XG4gICAgICAgICAgaWQ6IGBlZGdlLSR7bG9vcE5vZGVJZH0tJHt0YXJnZXROb2RlSWR9LWN5Y2xlYCxcbiAgICAgICAgICBzb3VyY2U6IHRhcmdldE5vZGVJZCxcbiAgICAgICAgICB0YXJnZXQ6IGxvb3BOb2RlSWQsXG4gICAgICAgICAgYW5pbWF0ZWQ6IHRydWUsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgY29uZGl0aW9uOiBFZGdlQ29uZGl0aW9uLkFMV0FZUyxcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBlZGdlczogWy4uLnN0YXRlLmVkZ2VzLCBuZXdFZGdlXSB9O1xuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFNldCBhIG5vZGUncyBwYXJlbnQgKGZvciBzdWJncmFwaHMpXG4gICAgICBzZXROb2RlUGFyZW50OiAobm9kZUlkLCBwYXJlbnRJZCkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkTm9kZXMgPSBzdGF0ZS5ub2Rlcy5tYXAobiA9PiB7XG4gICAgICAgICAgaWYgKG4uaWQgPT09IG5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ubixcbiAgICAgICAgICAgICAgcGFyZW50Tm9kZTogcGFyZW50SWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAvLyBJbmNyZWFzZSB6SW5kZXggd2hlbiBub2RlIGlzIG5lc3RlZFxuICAgICAgICAgICAgICB6SW5kZXg6IHBhcmVudElkID8gMTAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IG5vZGVzOiB1cGRhdGVkTm9kZXMgfTtcbiAgICAgIH0pLFxuICAgIH0pLFxuICAgIHtcbiAgICAgIG5hbWU6ICdsYW5nZ3JhcGgtc3RvcmFnZScsXG4gICAgfVxuICApXG4pO1xuXG5leHBvcnQgZGVmYXVsdCB1c2VHcmFwaFN0b3JlO1xuXG4vLyBDdXN0b20gaG9vayB0byBhY2Nlc3MgZ3JhcGggZGF0YSBjb252ZW5pZW50bHlcbmV4cG9ydCBjb25zdCB1c2VHcmFwaCA9ICgpID0+IHtcbiAgY29uc3Qgbm9kZXMgPSB1c2VHcmFwaFN0b3JlKHN0YXRlID0+IHN0YXRlLm5vZGVzKTtcbiAgY29uc3QgZWRnZXMgPSB1c2VHcmFwaFN0b3JlKHN0YXRlID0+IHN0YXRlLmVkZ2VzKTtcbiAgY29uc3QgZ3JhcGhOYW1lID0gdXNlR3JhcGhTdG9yZShzdGF0ZSA9PiBzdGF0ZS5ncmFwaE5hbWUpO1xuICByZXR1cm4geyBub2RlcywgZWRnZXMsIGdyYXBoTmFtZSB9O1xufTtcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJwZXJzaXN0IiwidmFsaWRhdGVFZGdlQ29ubmVjdGlvbiIsImhhc0N5Y2xlVG9Ob2RlIiwidGFyZ2V0Tm9kZUlkIiwiZWRnZXMiLCJ2aXNpdGVkIiwiU2V0IiwicGF0aCIsImN1cnJlbnROb2RlIiwic291cmNlc1RvVGFyZ2V0IiwiZmlsdGVyIiwiZSIsInRhcmdldCIsIm1hcCIsInNvdXJjZSIsImhhcyIsImFkZCIsIm91dGdvaW5nRWRnZXMiLCJlZGdlIiwiZGVsZXRlIiwiTm9kZVR5cGUiLCJFZGdlQ29uZGl0aW9uIiwiRVJST1JfTUVTU0FHRVMiLCJTVEFSVF9OT0RFX0VYSVNUUyIsIklOVkFMSURfQ09OTkVDVElPTiIsIlNUQVJUX1JFUVVJUkVEIiwiU1RBUlRfTk9fSU5DT01JTkciLCJTVEFSVF9PTkVfT1VUR09JTkciLCJFTkRfUkVRVUlSRUQiLCJFREdFX0ZST01fRU5EIiwiRFVQTElDQVRFX0VER0UiLCJTRUxGX0NPTk5FQ1RJT04iLCJQQVJBTExFTF9GT1JLX01JTl9FREdFUyIsIlBBUkFMTEVMX0pPSU5fTUlOX0VER0VTIiwiTE9PUF9DWUNMRV9SRVFVSVJFRCIsInVzZUdyYXBoU3RvcmUiLCJzZXQiLCJnZXQiLCJub2RlcyIsInNlbGVjdGVkTm9kZUlkIiwic2VsZWN0ZWRFZGdlSWQiLCJncmFwaE5hbWUiLCJlcnJvciIsImlzVmFsaWQiLCJzZXROb2RlcyIsInNldEVkZ2VzIiwiYWRkTm9kZSIsIm5vZGUiLCJ0eXBlIiwic29tZSIsIm4iLCJzdGF0ZSIsInZhbGlkIiwibWVzc2FnZSIsInZhbGlkYXRlR3JhcGgiLCJ1cGRhdGVOb2RlIiwiaWQiLCJkYXRhIiwidXBkYXRlZE5vZGVzIiwibmV3U3RhdGUiLCJyZW1vdmVOb2RlIiwiY2FuQWRkRWRnZSIsInNvdXJjZU5vZGUiLCJmaW5kIiwidGFyZ2V0Tm9kZSIsImFkZEVkZ2UiLCJ2YWxpZGF0aW9uUmVzdWx0IiwidXBkYXRlRWRnZSIsInVwZGF0ZWRFZGdlcyIsInJlbW92ZUVkZ2UiLCJzZXRTZWxlY3RlZE5vZGVJZCIsInNldFNlbGVjdGVkRWRnZUlkIiwic2V0R3JhcGhOYW1lIiwiY2xlYXJHcmFwaCIsInN0YXJ0Tm9kZXMiLCJsZW5ndGgiLCJzdGFydE5vZGVJZCIsInN0YXJ0Tm9kZU91dGdvaW5nRWRnZXMiLCJzdGFydE5vZGVJbmNvbWluZ0VkZ2VzIiwiZW5kTm9kZUlkcyIsImVuZE5vZGVPdXRnb2luZ0VkZ2VzIiwiaW5jbHVkZXMiLCJwYXJhbGxlbEZvcmtOb2RlcyIsImZvcmtOb2RlIiwicGFyYWxsZWxKb2luTm9kZXMiLCJqb2luTm9kZSIsImluY29taW5nRWRnZXMiLCJsb29wTm9kZXMiLCJsb29wTm9kZSIsImhhc0N5Y2xlIiwic2V0RXJyb3IiLCJhZGREZWNpc2lvbkJyYW5jaCIsIm5vZGVJZCIsImJyYW5jaE5hbWUiLCJjdXJyZW50QnJhbmNoZXMiLCJicmFuY2hlcyIsInJlbW92ZURlY2lzaW9uQnJhbmNoIiwiYnJhbmNoSW5kZXgiLCJzcGxpY2UiLCJhZGRMb29wQ3ljbGUiLCJsb29wTm9kZUlkIiwibmV3RWRnZSIsImFuaW1hdGVkIiwiY29uZGl0aW9uIiwic2V0Tm9kZVBhcmVudCIsInBhcmVudElkIiwicGFyZW50Tm9kZSIsInVuZGVmaW5lZCIsInpJbmRleCIsIm5hbWUiLCJ1c2VHcmFwaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/graphStore.ts\n"));

/***/ })

});